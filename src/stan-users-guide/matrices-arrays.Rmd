# Matrices, Vectors, and Arrays

# 矩阵、向量和数组

This chapter provides pointers as to how to choose among the various
matrix, vector, and array data structures provided by Stan.

本章节说明了如何选择Stan支持的数据结构，包括各类矩阵、向量和数组等。

## Basic motivation

## 基本动机

Stan provides two basic scalar types, `int` and `real`, and
three basic linear algebra types, `vector`, `row_vector`,
and `matrix`.  Then Stan allows arrays to be of any dimension and
contain any type of element (though that type must be declared and
must be the same for all elements).

Stan提供两种基本的标量类型：整数`int`和实数`real`，以及三种基本的线性代数类型：列向量`vector`、行向量`row_vector`和矩阵`matrix`。Stan中数组可以是任意维度的，且能包含任何类型的元素(但必须事先声明类型，并且所有元素都为该类型)。

This leaves us in the awkward situation of having three
one-dimensional containers, as exemplified by the following
declarations.

这让我们陷入了一个尴尬的境地，若有三个一维变量，它们的声明如下：

```stan
array[N] real a;
vector[N] a;
row_vector[N] a;
```

These distinctions matter.  Matrix types, like vector and row vector,
are required for linear algebra operations.  There is no automatic
promotion of arrays to vectors because the target, row vector or
column vector, is ambiguous.  Similarly, row vectors are separated
from column vectors because multiplying a row vector by a column
vector produces a scalar, whereas multiplying in the opposite order
produces a matrix.

这些区别很重要。首先，矩阵，包括列向量和行向量，是线性代数运算必需的。不存在自动将数组提升为向量的操作，因为转换目标（行向量或列向量）不明确。其次，行向量与列向量也是不同的，因为行向量与列向量相乘得到一个标量，而以相反顺序会得到一个矩阵。

The following code fragment shows all four ways to declare a
two-dimensional container of size $M \times N$.

下面的代码片段展示了声明大小为$M \times N$的二维变量的所有方法。

```stan
array[M, N] real b;          // b[m] : array[] real     (efficient)
array[M] vector[N] b;        // b[m] : vector     (efficient)
array[M] row_vector[N] b;    // b[m] : row_vector (efficient)
matrix[M, N] b;              // b[m] : row_vector (inefficient)
```

The main differences among these choices involve efficiency for
various purposes and the type of `b[m]`, which is shown in
comments to the right of the declarations.  Thus the only way to
efficiently iterate over row vectors is to use the third declaration,
but if you need linear algebra on matrices, but the only way to use
matrix operations is to use the fourth declaration.

这些选择的主要区别在于各种方法的效率和`b[m]`的类型，声明右侧的注释中有说明。可见有效遍历行向量的唯一方法是第三种声明；如果需要矩阵类型以进行线性代数运算，那么唯一方法是使用第四个声明。

The inefficiencies due to any manual reshaping of containers is
usually slight compared to what else is going on in a Stan program
(typically a lot of gradient calculations).

但与Stan程序中进行的其他操作（通常是大量的梯度计算）相比，任何手动重塑多维变量所导致的低效通常是可以忽略不计的。


## Fixed sizes and indexing out of bounds

## 固定尺寸和索引越界

Stan's matrices, vectors, and array variables are sized when they are
declared and may not be dynamically resized.  Function arguments do
not have sizes, but these sizes are fixed when the function is called
and the container is instantiated.  Also, declarations may be inside
loops and thus may change over the course of running a program, but
each time a declaration is visited, it declares a fixed size object.

Stan的矩阵、向量和数组变量需要在声明时确定维数，不能动态调整。函数参数不指定维数，但是这些维数大小在调用函数和实例化变量时被固定。此外，声明可能在循环中，因此可能在程序运行过程中发生变化，但是每次访问声明时，得到一个固定大小的对象。

When an index is provided that is out of bounds, Stan throws a
rejection error and computation on the current log density and
gradient evaluation is halted and the algorithm is left to clean up
the error.  All of Stan's containers check the sizes of all indexes.

当索引超出边界时，Stan抛出拒绝错误，停止当前对数密度和梯度的计算，并启用算法来清除错误。Stan会检查所有变量的索引的大小。


## Data type and indexing efficiency {#indexing-efficiency.section}

## 数据类型和索引效率{#indexing-efficiency.section}

The underlying matrix and linear algebra operations are implemented in
terms of data types from the Eigen C++ library.  By having vectors
and matrices as basic types, no conversion is necessary when invoking
matrix operations or calling linear algebra functions.

底层的矩阵和线性代数运算是根据Eigen、c++库的数据类型实现的。将向量和矩阵作为基本类型，在调用矩阵操作或线性代数函数时不需要进行数据类型的转换。

Arrays, on the other hand, are implemented as instances of the C++ \
`std::vector` class (not to be confused with Eigen's
`Eigen::Vector` class or Stan vectors).  By implementing arrays
this way, indexing is  efficient because values can be returned by
reference rather than copied by value.

另一方面，数组是通过C++`std::vector`类的实例实现的（不要与Eigen的`Eigen:: vector`类或Stan的向量混淆）。通过这种方式实现数组，索引是有效的，因为值可以通过引用返回，而不是值复制。

### Matrices vs.\ two-dimensional arrays {-}

### 矩阵与二维数组{-}

In Stan models, there are a few minor efficiency considerations in
deciding between a two-dimensional array and a matrix, which may seem
interchangeable at first glance.

在Stan模型中，乍一看二维数组和矩阵似乎可以互换，但在选择二维数组或矩阵时有一些有关效率的细节。

First, matrices use a bit less memory than two-dimensional arrays.
This is because they don't store a sequence of arrays, but just the
data and the two dimensions.

首先，矩阵比二维数组使用的内存略少。这是因为它们不存储数组序列，而只是存储数据和两个维度。

Second, matrices store their data in column-major order.  Furthermore,
all of the data in a matrix is guaranteed to be contiguous in memory.
This is an important consideration for optimized code because bringing
in data from memory to cache is much more expensive than performing
arithmetic operations with contemporary CPUs.  Arrays, on the other
hand, only guarantee that the values of primitive types are contiguous
in memory; otherwise, they hold copies of their values (which are
returned by reference wherever possible).

其次，矩阵以列为主顺序存储数据，且矩阵中数据在内存中保存位置连续，对于优化代码来说这是一个重要的考虑因素，因为将数据从内存读入缓存比使用CPU执行算术运算时间成本要昂贵得多。另一方面，数组只保证基本类型的值在内存中是连续的；否则，它们保存其值的副本（在可能的情况下通过引用返回）。

Third, both data structures are best traversed in the order in which
they are stored.  This also helps with memory locality.  This is
column-major for matrices, so the following order is appropriate.

第三，最好按照存储的顺序遍历这两个数据结构。这也有助于内存的局部性。矩阵按列的顺序存储，所以下面代码的遍历顺序是合适的。

```stan
matrix[M, N] a;
//...
for (n in 1:N) {
  for (m in 1:M) {
    // ... do something with a[m, n] ...
  }
}
```

Arrays, on the other hand, should be traversed in row-major order
(i.e., last index fastest), as in the following example.

另一方面，数组应该以行优先的顺序（即固定行序号，遍历列索引号）遍历，如下所示。

```stan
array[M, N] real a;
// ...
for (m in 1:M) {
  for (n in 1:N) {
    // ... do something with a[m, n] ...
  }
}
```

The first use of `a[m ,n]` should bring `a[m]` into memory.
Overall, traversing matrices is more efficient than traversing arrays.

第一次使用`a[m,n]`会将`a[m]`调用进内存。总的来说，遍历矩阵比遍历数组更有效。

This is true even for arrays of matrices.  For example, the ideal
order in which to traverse a two-dimensional array of matrices is

这对元素是矩阵的数组也是成立的，如遍历二维矩阵数组的理想顺序是：

```stan
array[I, J] matrix[M, N] b;
// ...
for (i in 1:I) {
  for (j in 1:J) {
    for (n in 1:N) {
      for (m in 1:M) {
        // ... do something with b[i, j, m, n] ...
      }
    }
  }
}
```

If `a` is a matrix, the notation `a[m]` picks out row
`m` of that matrix.  This is a rather inefficient operation for
matrices.  If indexing of vectors is needed, it is much better to
declare an array of vectors.  That is, this

如果`a`是一个矩阵，符号`a[m]`表示矩阵的第`m`行。对于矩阵来说，这是一个非常低效的操作。如果需要索引向量，最好声明一个向量数组，也就是：

```stan
array[M] row_vector[N] b;
// ...
for (m in 1:M) {
   // ... do something with row vector b[m] ...
}
```

is much more efficient than the pure matrix version

它比如下的纯矩阵更高效：

```stan
array[M, N] matrix b;
// ...
for (m in 1:M) {
   // ... do something with row vector b[m] ...
}
```

Similarly, indexing an array of column vectors is more efficient than
using the `col` function to pick out a column of a matrix.

类似地，选取矩阵列时，索引列向量数组比使用`col`函数更有效。

In contrast, whatever can be done as pure matrix algebra will be the
fastest.  So if I want to create a row of predictor-coefficient
dot-products, it's more efficient to do this

相比之下，任何可以用纯矩阵代数实现的操作都是最快的。如果想做一行预测系数的点积，这样

```stan
matrix[N, k] x;    // predictors (aka covariates)
// ...
vector[K] beta;   // coeffs
// ...
vector[N] y_hat;  // linear prediction
// ...
y_hat = x * beta;
```

than it is to do this

比以下方法

```stan
array[N] row_vector[K] x;    // predictors (aka covariates)
// ...
vector[K] beta;   // coeffs
// ...
vector[N] y_hat;  // linear prediction
// ...
for (n in 1:N) {
  y_hat[n] = x[n] * beta;
}
```

更有效率。

### (Row) vectors vs. one-dimensional arrays {-}

### (行)向量与一维数组 {-}

For use purely as a container, there is really nothing to decide among
vectors, row vectors and one-dimensional arrays.  The
`Eigen::Vector` template specialization and the
`std::vector` template class are implemented  similarly as
containers of `double` values (the type `real` in Stan).
Only arrays in Stan are allowed to store integer values.

只需要高维变量时，列向量、行向量和一维数组都可以使用。`Eigen::Vector`模板特化和`std:: Vector`模板类的实现类似于`double`值的多维变量(Stan中的`real`类型)。Stan中只有数组才允许存储整数值。


## Memory locality

## 内存局部性

The key to understanding efficiency of matrix and vector
representations is memory locality and reference passing versus
copying.

理解矩阵和向量表示效率的关键是内存局部性和引用的传递与复制。

### Memory locality {-}

### 内存局部性 {-}

CPUs on computers bring in memory in blocks through layers of caches.
Fetching from memory is *much* slower than performing arithmetic
operations.  The only way to make container operations fast is to
respect memory locality and access elements that are close together in
memory sequentially in the program.

计算机CPU通过缓存层以块的形式将数据读入内存。从内存中读取数据比运算要慢*得多*。使多维变量操作加快的唯一方法是遵循内存局部性，让程序依次访问内存中邻近的元素。

### Matrices {-}

### 矩阵 {-}

Matrices are stored internally in column-major order.  That is, an $M
\times N$ matrix stores its elements in the order
矩阵存储时以列为主顺序。也就是说，一个$M \times N$维的矩阵存储元素的顺序是
$$
(1,1), (2, 1), \dotsc, (M, 1), (1, 2), \dotsc, (M, 2), \dotsc, (1, N),
\dotsc, (M, N).
$$

This means that it's much more efficient to write loops over matrices
column by column, as in the following example.

因此在矩阵上逐列编写循环时效率要高得多，如下面的示例所示。

```stan
matrix[M, N] a;
// ...
for (n in 1:N) {
  for (m in 1:M) {
     // ... do something with a[m, n] ...
  }
}
```

It also follows that pulling a row out of a matrix is not memory
local, as it has to stride over the whole sequence of values.  It also
requires a copy operation into a new data structure as it is not
stored internally as a unit in a matrix.  For sequential access to row
vectors in a matrix, it is much better to use an array of row vectors,
as in the following example.

也就是说，从矩阵中取出一行不符合内存局部性，因为它必须跨越整个值序列。它还需要一个复制粘贴到一个新的数据结构，因为行本身不是矩阵内部的一个存储单位。对于顺序访问矩阵行向量，使用行向量数组要好得多，如

```stan
array[M] row_vector[N] a;
// ...
for (m in 1:M) {
  // ... do something with row vector a[m] ...
}
```

Even if what is done involves a function call, the row vector
`a[m]` will not have to be copied.

即使操作涉及函数调用，行向量`a[m]`也无需复制。

### Arrays {-}

### 数组 {-}

Arrays are stored internally following their data structure.  That
means a two dimensional array is stored in row-major order.  Thus it
is efficient to pull out a "row" of a two-dimensional array.

数组按照其数据结构进行存储。这意味着二维数组是按行为主顺序存储的。因此，提取二维数组的“行”是高效的。

```stan
array[M, N] real a;
// ...
for (m in 1:M) {
  // ... do something with a[m] ...
}
```

A difference with matrices is that the entries `a[m]` in the two
dimensional array are not necessarily adjacent in memory, so there are
no guarantees on iterating over all the elements in a two-dimensional
array will provide memory locality across the "rows."

数组与矩阵的不同之处在于，二维数组中的条目`a[m]`在内存中不一定相邻，因此不能保证遍历二维数组中的所有元素能够提供“行”间的内存局部性。

## Converting among matrix, vector, and array types

## 矩阵、向量、数组的相互转换

There is no automatic conversion among matrices, vectors, and arrays
in Stan.  But there are a wide range of conversion functions to
convert a matrix into a vector, or a multi-dimensional array into a
one-dimensional array, or convert a vector to an array.  See the
section on mixed matrix and array operations in the functions
reference manual for a complete list of conversion operators and the
[multi-indexing chapter](#multi-indexing.chapter) for some reshaping
operations involving multiple indexing and range indexing.

Stan没有矩阵、向量和数组之间的自动转换。但是有很多转换函数可以将矩阵转换为向量、将多维数组转换为一维数组、或将向量转换为数组。有关转换操作符的完整列表，请参阅函数参考手册中的混合矩阵和数组操作一节；有关涉及多个索引和范围索引的一些重塑操作，请参阅[多索引章节](#multi-indexing.chapter)。


## Aliasing in Stan containers

## Stan中多维变量的混叠

Stan expressions are all evaluated before assignment happens, so there
is no danger of so-called aliasing in array, vector, or matrix
operations.  Contrast the behavior of the assignments to `u` and
`x`, which start with the same values.

Stan表达式都在赋值之前求值，因此不存在数组、向量或矩阵操作混叠的危险。对比对`u`和`x`赋值的操作，二者有相同初值。

The loop assigning to `u` and the compound slicing assigning to `x`.

对`u`进行循环赋值，对`x`进行复合切片赋值。

 the following trivial Stan program.

以下是个简单的Stan程序。

```stan
transformed data {
  vector[4] x = [ 1, 2, 3, 4 ]';
  vector[4] u = [ 1, 2, 3, 4 ]';

  for (t in 2:4) {
    u[t] = u[t - 1] * 3;
  }

  x[2:4] = x[1:3] * 3;

  print("u = ", u);
  print("x = ", x);
}
```

The output it produces is,

它的输出是：

```
u = [1, 3, 9, 27]
x = [1, 3, 6, 9]
```

In the loop version assigning to `u`, the values are updated before being used to
define subsequent values;  in the sliced expression assigning to
`x`, the entire right-hand side is evaluated before assigning to
the left-hand side.

结果不同是由于：在赋值给`u`的循环中，值在用于定义后续值之前被更新；在对`x`赋值的切片表达式中，在对左侧赋值之前，对整个右侧进行求值。
