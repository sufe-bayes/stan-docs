---
pagetitle: Data Types and Declarations
---

# Data Types and Declarations {#data-types.chapter}

# 数据类型和声明

本章译者：徐彩霞 张广伟 顾辰菲 谭丽

分工细则：

徐彩霞：Overview of data types -- Affinely transformed real

张广伟：Expressions as bounds and offset/multiplier -- Expressions as size declarations

顾辰菲：Accessing vector and matrix elements -- Unpacking assignment of tuples

谭丽：Variable types vs. constraints and sizes -- Combining with other features

This chapter covers the data types for expressions in Stan.  Every
variable used in a Stan program must have a declared data type.  Only
values of that type will be assignable to the variable (except for
temporary states of transformed data and transformed parameter
values).  This follows the convention of programming languages like
C++, not the conventions of scripting languages like Python or
statistical languages such as R or BUGS.

本章介绍了 Stan 表达式中的数据类型。在 Stan 程序中使用的每个变量都必须有声明的数据类型。只有该类型的值才能赋给变量（除了转换数据和转换参数值的临时状态）。这遵循了像 C++ 这样的编程语言的惯例，而不是像 Python、R 或 BUGS 这样的脚本语言或统计语言的惯例。

The motivation for strong, static typing is threefold.

1. Strong typing forces the programmer's intent to be declared with
  the variable, making programs easier to comprehend and hence easier
  to debug and maintain.
2. Strong typing allows programming errors relative to the declared
  intent to be caught sooner (at compile time) rather than later (at
  run time).  The Stan compiler (called through an interface such as
  CmdStan, RStan, or PyStan) will flag any type errors and indicate
  the offending expressions quickly when the program is compiled.
3. Constrained types will catch runtime data, initialization, and
  intermediate value errors as soon as they occur rather than allowing
  them to propagate and potentially pollute final results.

强静态类型的动机有三个方面：

1.  强类型要求程序员在变量声明时表明其意图，使程序更易于理解，因此更易于调试和维护。

2.  强类型允许更早地捕获与声明意图相关的编程错误（在编译时而不是运行时）。Stan 编译器（通过诸如 CmdStan、RStan 或 PyStan 之类的接口调用）将在程序编译时迅速标记任何类型错误并指出有问题的表达式。

3.  受限类型将在发生运行时数据、初始化和中间值错误时立即捕获它们，而不是允许它们传播并出现影响最终结果的可能。

Strong typing disallows assigning the same variable to objects of
different types at different points in the program or in different
invocations of the program.

强类型禁止在程序的不同点或不同调用中将同一变量分配给不同类型的对象。

## Overview of data types

## 数据类型概述

Arguments for built-in and user-defined functions and local variables
are required to be basic data types, meaning an unconstrained scalar,
vector, or matrix type, or an array of such.

内置和用户定义函数的参数以及局部变量应是基本数据类型，即无约束的标量、向量或矩阵类型，或者是这些类型的数组。

Passing arguments to functions in Stan works just like assignment to
basic types.  Stan functions are only specified for the basic data
types of their arguments, including array dimensionality, but not for
sizes or constraints.  Of course, functions often check constraints as
part of their behavior.

在 Stan 中，将参数传递给函数的方式类似于对基本类型赋值。Stan 函数仅针对其参数的基本数据类型进行指定，包括数组维度，但不包括大小或约束。当然，函数通常会作为其行为的一部分检查约束。

### Primitive types {-}

### 初始数据类型

Stan provides two primitive data types, `real` for continuous
values and `int` for integer values.  These are both considered scalar
types.

Stan 提供了两种原始数据类型，`real` 用于连续值，`int` 用于整数值。这两种都被认为是标量类型。

### Complex types {-}

### 复数数据类型

Stan provides a complex number data type `complex`, where a complex
number contains both a real and an imaginary component, both of which
are of type `real`.  Complex types are considered scalar types.

Stan 还提供了复数数据类型 `complex`，其中复数包含实部和虚部，两者都是`real`类型。复数类型被认为是标量类型。

### Vector and matrix types {-}

### 向量和矩阵类型

Stan provides three real-valued matrix data types, `vector` for column
vectors, `row_vector` for row vectors, and `matrix` for
matrices.

Stan 提供了三种实数矩阵数据类型，`vector`用于列向量，`row_vector`用于行向量，`matrix`用于矩阵。

Stan also provides three complex-valued matrix data types,
`complex_vector` for column vectors, `complex_row_vector` for row
vectors, and `complex_matrix` for matrices.

Stan 还提供了三种复数矩阵数据类型：complex_vector用于列向量，complex_row_vector 用于行向量，以及 complex_matrix 用于矩阵。

### Array types {-}

### 数组类型

Any type (including the constrained types discussed in the next
section) can be made into an array type by declaring array arguments.
For example,

任何类型（包括下一节讨论的约束类型）都可以通过声明数组参数来制成数组类型。例如：

```stan
array[10] real x;
array[6, 7] matrix[3, 3] m;
array[12, 8, 15] complex z;
```

declares `x` to be a one-dimensional array of size 10 containing
real values, declares `m` to be a two-dimensional array of
size $6 \times 7$ containing values that are $3 \times 3$ matrices,
and declares `z` to be a $12 \times 8 \times 15$ array of complex numbers.

指定 `x` 为一个包含实数值的一维数组，大小为 10；指定 `m` 为一个包含 $3 \times 3$ 矩阵的值的二维数组，大小为 $6\times7$；指定 `z` 为一个复数的 $12 \times 8 \times 5$ 数组。

Prior to 2.26 Stan models used a different syntax which has since been removed.
See the [Removed Features](removals.qmd) chapter for more details.

在 2.26 版本之前，Stan模型采用了一种不同的语法，此后已将其移除。有关更多详细信息，请参阅 [Removed Features] 章节。

### Tuple types {-}

### 元组类型

For any sequence of types, Stan provides a tuple data type.  For example,

对于任何类型的序列，Stan提供了元组数据类型。例如，

```stan
tuple(real, array[5] int) xi;
```

declares `xi` to be a tuple holding two values, the first of which is
of type type `real` and the second of which a 5-dimensional array of
type `int`.

定义 `xi` 为一个元组，其中包含两个值，第一个值的类型为 `real`，第二个值的类型为类型为 `int` 的 5 维数组。


### Constrained data types

### 有约束的数据类型

Declarations of variables other than local variables may be provided
with constraints.  These constraints are not part of the underlying
data type for a variable, but determine error checking in the
transformed data, transformed parameter, and generated quantities
block, and the transform from unconstrained to constrained space in
the parameters block.

除了局部变量之外，变量的声明可以附加约束。这些约束并不是变量底层数据类型的一部分，但它们决定了在转换数据、转换参数和生成量块中的错误检查，以及在参数块中从无约束空间到有约束空间的转换。

All of the basic data types other than `complex` may be given lower
and upper bounds using syntax such as

除了复数之外，所有基本数据类型都可以使用以下语法给定下界和上界：

```stan
int<lower=1> N;
real<upper=0> log_p;
vector<lower=-1, upper=1>[3] rho;
```

There are also special data types for structured vectors and
matrices. There are five constrained vector data types, `simplex`
for unit simplexes, `unit_vector` for unit-length vectors,
`sum_to_zero_vector` for vectors that sum to zero,
`ordered` for ordered vectors of scalars, and
`positive_ordered` for vectors of positive ordered
scalars. There are specialized matrix data types `corr_matrix`
and `cov_matrix` for correlation matrices (symmetric, positive
definite, unit diagonal) and covariance matrices (symmetric, positive
definite).  The type `cholesky_factor_cov` is for Cholesky
factors of covariance matrices (lower triangular, positive diagonal,
product with own transpose is a covariance matrix).  The type
`cholesky_factor_corr` is for Cholesky factors of correlation
matrices (lower triangular, positive diagonal, unit-length rows).

还有用于结构化向量和矩阵的特殊数据类型。有四种受约束的向量数据类型，`simplex` 用于单位单纯形，`unit_vector` 用于单位长度向量，`ordered` 用于有序标量向量，`positive_ordered` 用于正有序标量向量。还有专门的矩阵数据类型 `corr_matrix` 和 `cov_matrix` 用于相关矩阵（对称、正定、单位对角线）和协方差矩阵（对称、正定）。`cholesky_factor_cov` 类型用于协方差矩阵的 Cholesky 分解因子（下三角、正对角线、与自身转置的乘积是一个协方差矩阵）。`cholesky_factor_corr` 类型用于相关矩阵的 Cholesky 分解因子（下三角、正对角线、单位长度的行）。

Constraints provide error checking for variables defined in the
`data`, `transformed data`, `transformed parameters`,
and `generated quantities` blocks.  Constraints are critical for
variables declared in the `parameters` block, where they
determine the transformation from constrained variables (those
satisfying the declared constraint) to unconstrained variables (those
ranging over all of $\mathbb{R}^n$).

约束为在数据块、转换数据块、转换参数块和生成数量块中定义的变量提供误差检查。对于在参数块中声明的变量来说，约束至关重要，因为它们确定了从受约束变量（满足声明约束的变量）到无约束变量（范围涵盖所有$\mathbb{R}^n$中的可能值）的转换方式。

It is worth calling out the most important aspect of constrained data
types:
值得强调的是受限数据类型最重要的方面：

<div style="margin:0 2em 0 2em">
*The model must have support (non-zero density, equivalently finite
log density) at parameter values that satisfy the declared
constraints.*
</div>

<div style="margin:0 2em 0 2em">
*模型必须在满足声明约束的参数值处有支持（即非零密度，等价于有限的对数密度）。*
</div>


If this condition is violated with parameter values that satisfy
declared constraints but do not have finite log density, then the
samplers and optimizers may have any of a number of pathologies
including just getting stuck, failure to initialize, excessive
Metropolis rejection, or biased draws due to inability to explore
the tails of the distribution.

如果违反了这个条件，即参数值满足声明的约束但没有有限的对数密度，那么采样器和优化器可能会出现多种问题，包括卡住不动、初始化失败、过度的 Metropolis 拒绝，或者由于无法探索分布的尾部而导致抽样偏差。

## Primitive numerical data types {#numerical-data-types}

## 初始数值数据类型

Unfortunately, the lovely mathematical abstraction of integers and
real numbers is only partially supported by finite-precision computer
arithmetic.

不幸的是，整数和实数这种美妙的数学抽象只能被有限精度的计算机算术部分支持。

### Integers {-}

### 整数

Stan uses 32-bit (4-byte) integers for all of its integer
representations.  The maximum value that can be represented
as an integer is $2^{31}-1$; the minimum value is $-(2^{31})$.

Stan 在其所有整数表示中使用 32 位（4 字节）整数。可以表示为整数的最大值是 $2^{31} - 1$；最小值是 $(-2^{31})$。

When integers overflow, their value is determined by the underlying architecture.
On most, their values wrap, but this cannot be guaranteed.  Thus it is up to the Stan
programmer to make sure the integer values in their programs stay in
range.  In particular, every intermediate expression must have an
integer value that is in range.

当整数溢出时，它们的值由底层架构决定。在大多数情况下，它们的值会回绕，但这不能保证。因此，Stan程序员必须确保他们程序中的整数值保持在范围内。特别是，每个中间表达式都必须有一个在范围内的整数值。

Integer arithmetic works in the expected way for addition,
subtraction, and multiplication, but truncates the result of division
(see [the Stan Functions Reference integer-valued arithmetic operators
section](https://mc-stan.org/docs/functions-reference/integer-valued_basic_functions.html#int-arithmetic)
for more information).

整数算术对于加法、减法和乘法按预期方式工作，但除法的结果会被截断（有关更多信息，请参见[Stan函数参考手册中的整数值算术运算符部分](https://mc-stan.org/docs/functions-reference/integer-valued_basic_functions.html#int-arithmetic)）。

### Reals {-}

### 实数

Stan uses 64-bit (8-byte) floating point representations of real
numbers.  Stan roughly^[Stan compiles integers to `int` and reals to `double` types in C++.  Precise details of rounding will depend on the compiler and hardware architecture on which the code is run.]
follows the IEEE 754 standard for floating-point computation.
The range of a 64-bit number is roughly $\pm 2^{1022}$, which is
slightly larger than $\pm 10^{307}$.  It is a good idea to stay well
away from such extreme values in Stan models as they are prone to
cause overflow.

Stan 使用 64 位（8字节）浮点表示法来表示实数。Stan 大致遵循 IEEE 754 标准进行浮点计算。64 位数的范围大致是 $\pm2^{1022}$，稍微大于 $\pm10^{3-7}$。在 Stan 模型中最好避免数据接近极端值，因为它们容易导致溢出。

64-bit floating point representations have roughly 15 decimal digits
of accuracy.  But when they are combined, the result often has less
accuracy.  In some cases, the difference in accuracy between two
operands and their result is large.

64 位浮点表示法大约有 15 位小数的精度。但当它们组合在一起时，结果通常精度更低。在某些情况下，两个操作数与其结果之间的精度差异很大。

There are three special real values used to represent (1) not-a-number
value for error conditions, (2) positive infinity for overflow, and
(3) negative infinity for overflow.  The behavior of these special
numbers follows standard IEEE 754 behavior.

有三个特殊的实数值用来表示：(1) 非数字值，用于错误条件；(2) 正无穷大，用于溢出；(3) 负无穷大，也用于溢出。这些特殊数字的行为遵循 IEEE 754 标准的行为。

#### Not-a-number {-}

#### 非数字值

The not-a-number value propagates.  If an argument to a real-valued
function is not-a-number, it either rejects (an exception in the
underlying C++) or returns not-a-number itself.  For boolean-valued
comparison operators, if one of the arguments is not-a-number, the
return value is always zero (i.e., false).

非数字值会传递。如果一个实数值函数的参数是非数字，它要么拒绝（底层 C++ 的一个异常），要么返回非数字本身。对于布尔值比较运算符，如果其中一个参数是非数字，返回值总是零（即，false）。

#### Infinite values {-}

#### 无穷值

Positive infinity is greater than all numbers other than itself and
not-a-number; negative infinity is similarly smaller.  Adding an
infinite value to a finite value returns the infinite value.  Dividing
a finite number by an infinite value returns zero; dividing an
infinite number by a finite number returns the infinite number of
appropriate sign.  Dividing a finite number by zero returns positive
infinity. Dividing two infinite numbers produces a not-a-number value
as does subtracting two infinite numbers.  Some functions are
sensitive to infinite values; for example, the exponential function
returns zero if given negative infinity and positive infinity if given
positive infinity.  Often the gradients will break down when values
are infinite, making these boundary conditions less useful than they
may appear at first.

正无穷大于除自身和非数字外的所有数字；负无穷亦然，它比所有数字都小。将无穷大值加到有限值上，结果仍为无穷大值。将有限数除以无穷大值，结果为零；将无穷大数除以有限数，结果为相应符号的无穷大数。将有限数除以零，结果为正无穷。将两个无穷大数相除，以及将两个无穷大数相减，结果都是非数字值。某些函数对无穷大值敏感；例如，指数函数如果给定负无穷将返回零，如果给定正无穷将返回正无穷。通常当值为无穷大时，梯度会失效，使得这些边界条件看似有用，实际上却不那么实用。


### Promoting integers to reals {-}

### 将整数提升为实数

Stan automatically promotes integer values to real values if
necessary, but does not automatically demote real values to integers.
For very large integers, this will cause a rounding error to fewer
significant digits in the floating point representation than in the
integer representation.

Stan 在必要时会自动将整数值提升为实数值，但不会自动将实数值降级为整数。对于非常大的整数，这将导致在浮点表示中相比于整数表示有更少的有效数字位的舍入误差。

Unlike in C++, real values are never demoted to integers.  Therefore,
real values may only be assigned to real variables.  Integer values
may be assigned to either integer variables or real variables.
Internally, the integer representation is cast to a floating-point
representation.  This operation is not without overhead and should
thus be avoided where possible.

与 C++ 不同，实数值从不降级为整数。因此，实数值只能分配给实数变量。整数值可以分配给整数变量或实数变量。在内部，整数表示被转换为浮点表示。这个操作并非没有代价，因此应尽可能避免。

## Complex numerical data type

## 复数数据类型

The `complex` data type is a scalar, but unlike `real` and `int`
types, it contains two components, a real and imaginary component,
both of which are of type `real`.  That is, the real and imaginary
components of a complex number are 64-bit, IEEE 754-complaint floating
point numbers.

复数数据类型是一个标量，但与实数和整数类型不同，它包含两个部分，一个实部和一个虚部，这两部分都是实数类型。也就是说，复数的实部和虚部都是 64 位，符合 IEEE 754 标准的浮点数。

### Constructing and accessing complex numbers {-}

### 构造和访问复数数据

Imaginary literals are written in mathematical notation using a
numeral followed by the suffix `i`.  For example, the following
example constructs a complex number $2 - 1.3i$ and assigns it to
the variable `z`.

虚数字面量在数学表示法中是用一个数字后面跟上字母 i 来写的。例如，下面的例子构造了一个复数并将其赋值给变量 z。

```stan
complex z = 2 - 1.3i;
real re = get_real(z);  // re has value 2.0
real im = get_imag(z);  // im has value -1.3
```

``` stan
complex z = 2 - 1.3i;
real re = get_real(z); // re 的值为 2.0
real im = get_imag(z); // im 的值为 -1.3
```

The getter functions then extract the real and imaginary components of
`z` and assign them to `re` and `im` respectively.

获取函数随后提取 `z` 的实部和虚部，并分别将它们赋值给 `re` 和 `im`。

The function `to_complex` constructs a complex number from its real
and imaginary components.  The functional form needs to be used
whenever the components are not literal numerals, as in the following
example.

`to_complex` 函数从其实部和虚部构造一个复数。当组件不是字面数字时，需要使用函数形式，如下例所示。

```stan
vector[K] re;
vector[K] im;
// ...
for (k in 1:K) {
  complex z = to_complex(re[k], im[k]);
  // ...
}
```

### Promoting real to complex {-}

### 将实数提升为复数

Expressions of type `real` may be assigned to variables of type
`complex`.  For example, the following is a valid sequence of Stan
statements.

实数类型的表达式可以赋值给复数类型的变量。例如，以下是一系列有效的 Stan 语句。


```stan
real x = 5.0;
complex z = x;  // get_real(z) == 5.0, get_imag(z) == 0
```

The real number assigned to a complex number determine's the complex
number's real component, with the imaginary component set to zero.

实数赋值给复数时，该实数将成为复数的实部分量，而虚部分量将被设定为零。


Assignability is transitive, so that expressions of type `int` may
also be assigned to variables of type `complex`, as in the following
example.

可赋性是传递的，这意味着整数型的表达式也可以赋值给复数类型的变量，如下例所示。


```stan
int n = 2;
complex z = n;
```

Function arguments also support promotion of integer or real typed
expressions to type `complex`.

函数参数也支持将整数或实数类型的表达式提升为复数类型。

## Scalar data types and variable declarations

## 标量数据类型和变量声明

All variables used in a Stan program must have an explicitly declared
data type.  The form of a declaration includes the type and the name
of a variable.  This section covers scalar types, namely integer,
real, and complex.  The next section covers vector and matrix types,
and the following section array types.

在 Stan 程序中使用的所有变量都必须有明确声明的数据类型。声明的形式包括变量的类型和名称。本节涵盖了标量类型，即整数、实数和复数。下一节将介绍向量和矩阵类型，再下一节将介绍数组类型。


### Unconstrained integer {-}

### 无约束整数


Unconstrained integers are declared using the `int` keyword.
For example, the variable `N` is declared to be an integer as follows.

无约束整数使用 `int` 关键字声明。例如，变量 `N` 被声明为一个整数，如下所示。


```stan
int N;
```


### Constrained integer {-}

### 有约束整数

Integer data types may be constrained to allow values only in a
specified interval by providing a lower bound, an upper bound, or
both.  For instance, to declare `N` to be a positive integer, use
the following.

整数数据类型可以通过提供下限、上限或两者来限制只允许在指定区间的值。例如，要声明`N`为一个正整数，可以使用以下方法。


```stan
int<lower=1> N;
```

This illustrates that the bounds are inclusive for integers.

这说明整数的界限是包含性的。


To declare an integer variable `cond` to take only binary values,
that is zero or one, a lower and upper bound must be provided, as in
the following example.

要声明一个整数变量 `cond` 只取二进制值，即零或一，必须提供一个下界和上界，如下例所示。


```stan
int<lower=0, upper=1> cond;
```


### Unconstrained real {-}

### 无约束实数


Unconstrained real variables are declared using the keyword
`real`. The following example declares `theta` to be an
unconstrained continuous value.

在声明无约束实数变量时，使用关键字 `real`。以下示例声明 `theta` 为一个不受约束的连续值。


```stan
real theta;
```

### Unconstrained complex {-}

### 无约束复数


Unconstrained complex numbers are declared using the keyword
`complex`.  The following example declares `z` to be an unconstrained
complex variable.

无约束复数使用关键字 `complex` 声明。以下示例将 `z` 声明为一个无约束的复数变量。

```stan
complex z;
```


### Constrained real {-}

### 有约束实数


Real variables may be bounded using the same syntax as integers.  In
theory (that is, with arbitrary-precision arithmetic), the bounds on
real values would be exclusive.  Unfortunately, finite-precision
arithmetic rounding errors will often lead to values on the
boundaries, so they are allowed in Stan.

实数变量可以使用与整数相同的语法进行限定。理论上（即使用任意精度算术），实数值的界限应该是排他性的。然而，由于有限精度算术的舍入误差，通常会导致值位于边界上，因此在 Stan 中是被允许的。


The variable `sigma` may be declared to be non-negative as follows.

下列语句可以指定变量 `sigma` 为非负的。


```stan
real<lower=0> sigma;
```

The following declares the variable `x` to be less than or equal
to $-1$.

下列语句指定变量 `x` 小于等于 $-1$。


```stan
real<upper=-1> x;
```

To ensure `rho` takes on values between $-1$ and $1$, use the
following declaration.

为确保 `rho` 在 $-1$ 到 $1$ 间取值，使用以下申明指定，


```stan
real<lower=-1, upper=1> rho;
```

#### Infinite constraints {-}

#### 无穷约束

Lower bounds that are negative infinity or upper bounds that are
positive infinity are ignored.  Stan provides constants
`positive_infinity()` and `negative_infinity()` which may
be used for this purpose, or they may be supplied as data.

下界为负无穷大或上界为正无穷大的情况将被忽略。Stan 提供了常数 `positive_infinity()` 和 `negative_infinity()`，可以用于此目的，或者它们可以作为数据以转储格式进行读取。



### Affinely transformed real {#affine-transform.section}

### 仿射变换实数

Real variables may be declared on a space that has been transformed using an
affine transformation $x\mapsto \mu + \sigma * x$ with offset $\mu$ and
(positive) multiplier $\sigma$, using a syntax similar to
that for bounds.
While these transforms do not change the asymptotic sampling behaviour of
the resulting Stan program (in a sense, the model the program implements),
they can be useful for making the sampling process
more efficient by transforming the geometry of the problem to a more natural
multiplier and to a more natural offset for the sampling process,
for instance by facilitating a non-centered parameterisation.
While these affine transformation declarations do not impose a hard constraint
on variables, they behave like the bounds constraints in many ways and could
perhaps be viewed as acting as a sort of soft constraint.

实数变量可以在经过仿射变换 $x \to \mu +\sigma *x$ 的空间上声明，其中包含偏移量 $\mu$ 和（正的）乘数 $\sigma$，其语法类似于用于界限的语法。尽管这些变换不会改变结果 Stan 程序（在某种意义上，即程序实现的模型）的渐近采样行为，但它们可以通过将问题的几何形状转换为更自然的倍增器和更自然的偏移量来使采样过程更有效率，例如通过促进非中心参数化。虽然这些仿射变换声明不会对变量施加硬约束，但它们在许多方面的行为类似于边界约束，并且也可以被视为一种软约束的一种形式。

The variable `x` may be declared to have offset $1$ as follows.

变量 `x` 可以被指定为具有偏移量 $1$ 如下。

```stan
real<offset=1> x;
```

Similarly, it can be declared to have multiplier $2$ as follows.

类似的，可以按如下方式声明其是具有倍增器为 $2$ 的变量。

```stan
real<multiplier=2> x;
```

Finally, we can combine both declarations to declare a variable with offset
$1$ and multiplier $2$.

最后，我们可以将两个声明结合起来，声明一个具有偏移量为 $1$ 和倍增器 $2$ 的变量。


```stan
real<offset=1, multiplier=2> x;
```

As an example, we can give `x` a normal distribution with non-centered
parameterization as follows.

例如，我们可以给 `x` 分配一个具有非中心参数化的正态分布，如下所示。


```stan
parameters {
  real<offset=mu, multiplier=sigma> x;
}
model {
  x ~ normal(mu, sigma);
}
```

Recall that the centered parameterization is achieved with the code

注意使用以下代码可以实现中心参数化：


```stan
parameters {
  real x;
}
model {
  x ~ normal(mu, sigma);
}
```

or equivalently
或最终有


```stan
parameters {
  real<offset=0, multiplier=1> x;
}
model {
  x ~ normal(mu, sigma);
}
```

### Expressions as bounds and offset/multiplier {-}

### 作为边界和偏移/乘数的表达式


Bounds (and offset and multiplier)
for integer or real variables may be arbitrary expressions.
The only requirement is that they only include variables that have
been declared (though not necessarily defined) before the declaration.  array[N] row_vector[D] x;
If the bounds themselves are parameters, the behind-the-scenes
variable transform accounts for them in the log Jacobian.

整数或实数变量的边界（以及偏移和乘数）可以是任意表达式。唯一的要求是这些表达式中只包括在声明之前已经被声明的变量（尽管这些变量不必已经被定义）。例如，当声明如 array[N] row_vector[D] x; 的数组时，如果边界本身为参数，则在后台的变量转换将在对数雅可比中考虑这些边界。


For example, it is acceptable to have the
following declarations.

例如，以下的声明是可以接受的：


```stan
data {
 real lb;
}
parameters {
   real<lower=lb> phi;
}
```

This declares a real-valued parameter `phi` to take values
greater than the value of the real-valued data variable `lb`.
Constraints may be arbitrary expressions, but must be of type `int`
for integer variables and of type `real` for real variables
(including constraints on vectors, row vectors, and matrices).
Variables used in constraints can be any variable that has been
defined at the point the constraint is used.  For instance,

这样声明了一个实数参数 `phi`，其取值大于实数数据变量 `lb` 的值。约束可以是任意表达式，但对于整型变量必须是 `int` 类型，对于实数变量必须是 `real` 类型（包括对向量、行向量和矩阵的约束）。在约束中使用的变量可以是在使用约束时已经定义的任何变量。例如，

```stan
data {
   int<lower=1> N;
   array[N] real y;
}
parameters {
   real<lower=min(y), upper=max(y)> phi;
}
```

This declares a positive integer data variable `N`, an array
`y` of real-valued data of length `N`, and then a parameter
ranging between the minimum and maximum value of `y`.  As shown
in the example code, the functions `min()` and `max()` may
be applied to containers such as arrays.

这声明了一个正整数数据变量 `N`，一个长度为 `N` 的实数数据数组 `y`，然后声明了一个参数，其取值范围在 `y` 的最小值和最大值之间。如示例代码所示，函数 `min()` 和 `max()` 可以应用于诸如数组之类的容器。


A more subtle case involves declarations of parameters or transformed
parameters based on parameters declared previously.  For example, the
following program will work as intended.

更微妙的情况涉及基于之前声明的参数声明参数或变换参数。例如，以下程序将按预期工作。


```stan
parameters {
  real a;
  real<lower=a> b;  // enforces a < b
}
transformed parameters {
  real c;
  real<lower=c> d;
  c = a;
  d = b;
}
```


``` stan
parameters {
real a;
real<lower=a> b;  // 强制 a < b
}
transformed parameters {
real c;
real<lower=c> d;
c = a;
d = b;
}
```

The parameters instance works because all parameters are defined
externally before the block is executed.  The transformed parameters
case works even though `c` isn't defined at the point it is used,
because constraints on transformed parameters are only validated at
the end of the block.  Data variables work like parameter variables,
whereas transformed data and generated quantity variables work like
transformed parameter variables.

参数实例之所以有效，是因为所有参数都在执行块之前被外部定义。即使在使用 `c` 时未定义，变换参数的情况也同样有效，因为对变换参数的约束只在块的末尾进行验证。数据变量的工作方式类似于参数变量，而变换数据和生成量变量的工作方式则类似于变换参数变量。

### Declaring optional variables {-}

### 声明可选变量

A variable may be declared with a size that depends on a boolean
constant.  For example, consider the definition of `alpha` in the
following program fragment.

变量可以声明为依赖于布尔常数的大小。例如，考虑以下程序片段中 `alpha` 的定义。


```stan
data {
  int<lower=0, upper=1> include_alpha;
  // ...
}
parameters {
  vector[include_alpha ? N : 0] alpha;
  // ...
}
```

If `include_alpha` is true, the model will include the vector
`alpha`;  if the flag is false, the model will not include
`alpha` (technically, it will include `alpha` of size 0,
which means it won't contain any values and won't be included in any
output).

如果 `include_alpha` 为真，模型将包含向量 `alpha`；如果此标志为假，则模型不会包括 `alpha`（技术上讲，它会包括一个大小为0的 `alpha`，这意味着它不包含任何值，也不会包括在任何输出中）。

This technique is not just useful for containers.  If the value of
`N` is set to 1, then the vector `alpha` will contain a
single element and thus `alpha[1]` behaves like an optional
scalar, the existence of which is controlled by `include_alpha`.

这种技术不仅适用于容器。如果 `N` 的值设为1，则向量 `alpha` 将包含一个单独的元素，因此 `alpha[1]` 的行为类似于一个可选的标量，其存在由 `include_alpha` 控制。


This coding pattern allows a single Stan program to define different
models based on the data provided as input.  This strategy is used
extensively in the implementation of the [RStanArm package](https://mc-stan.org/rstanarm).

这种编码模式允许单个Stan程序根据作为输入提供的数据定义不同的模型。这种策略在 [RStanArm 包](https://mc-stan.org/rstanarm)的实现中得到了广泛使用。


## Vector and matrix data types

## 向量和矩阵数据类型

Stan provides three types of container objects: arrays, vectors, and
matrices. Vectors and matrices are more limited kinds of data
structures than arrays.  Vectors are intrinsically one-dimensional
collections of real or complex values, whereas matrices are
intrinsically two dimensional.  Vectors, matrices, and arrays are not
assignable to one another, even if their dimensions are identical.  A
$3 \times 4$ matrix is a different kind of object in Stan than a $3
\times 4$ array.

Stan 提供三种类型的容器对象：数组、向量和矩阵。向量和矩阵是比数组更受限的数据结构类型。向量本质上是一维的实数或复数值集合，而矩阵本质上是二维的。即使维度相同，向量、矩阵和数组也不能相互赋值。在Stan中，$3\times 4$ 矩阵与 $3\times 4$ 数组是不同类型的对象。


The intention of using matrix types is to call out their usage in the
code.  There are three situations in Stan where *only* vectors and
matrices may be used,

使用矩阵类型的目的是在代码中明确其用途。在Stan中，只有在以下三种情况下才使用向量和矩阵：


* matrix arithmetic operations (e.g., matrix multiplication)
* 矩阵运算操作（例如，矩阵乘法）
* linear algebra functions (e.g., eigenvalues and determinants),
  and
* 线性代数函数（例如，特征值和行列式），以及
* multivariate function parameters and outcomes (e.g.,
  multivariate normal distribution arguments).
* 多变量函数的参数和结果（例如，多变量正态分布的参数）

Vectors and matrices cannot be typed to return integer values.  They
are restricted to `real` and `complex` values.

向量和矩阵不能设置为返回整数值。它们仅限于 `real` 和 `complex` 值。

For constructing vectors and matrices in Stan, see [Vector, Matrix,
and Array Expressions](expressions.qmd#vector-matrix-array-expressions.section).

关于在Stan中构造向量和矩阵的信息，请参见[向量、矩阵和数组表达式](https://mc-stan.org/docs/reference-manual/expressions.html#vector-matrix-array-expressions.section)。

### Indexing from 1 {-}

### 从1开始索引

Vectors and matrices, as well as arrays, are indexed starting from one
(1) in Stan.  This follows the convention in statistics and linear
algebra as well as their implementations in the statistical software
packages R, MATLAB, BUGS, and JAGS.  General computer programming
languages, on the other hand, such as C++ and Python, index arrays
starting from zero.

在Stan中，向量、矩阵以及数组的索引都是从一（1）开始。这遵循了统计学和线性代数以及在统计软件包 R、MATLAB、BUGS 和 JAGS 中的实现惯例。另一方面，通用计算机编程语言，如 C++ 和 Python，从零开始索引数组。

### Vectors {-}

### 向量

Vectors in Stan are column vectors; see below for information on row
vectors.  Vectors are declared with a size (i.e., a dimensionality).
For example, a 3-dimensional real vector is declared with the keyword
`vector`, as follows.

Stan中的向量是列向量；关于行向量的信息见下文。向量在声明时需要指定大小（即维度）。例如，一个三维实数向量的声明如下所示。


```stan
vector[3] u;
```

Vectors may also be declared with constraints, as in the following
declaration of a 3-vector of non-negative values.

向量也可以声明带有约束，如下面声明的非负值的三维向量。

```stan
vector<lower=0>[3] u;
```

Similarly, they may be declared with a offset and/or multiplier, as in the
following example

同样，向量也可以声明带有偏移量和/或乘数，如以下示例所示：

```stan
vector<offset=42, multiplier=3>[3] u;
```

### Complex vectors {-}

### 复数向量

Like real vectors, complex vectors are column vectors and are declared
with a size.  For example, a 3-dimensional complex vector is declared
with the keyword `complex_vector`, as follows.

与实数向量一样，复数向量是列向量，并且在声明时需要指定大小。例如，一个三维复数向量的声明使用关键字 `complex_vector`，如下所示：


```stan
complex_vector[3] v;
```

Complex vector declarations do not support any constraints.

复数向量的声明不支持任何约束。


### Unit simplexes {-}

### 单位单纯形


A unit simplex is a vector with non-negative values whose entries sum
to 1.  For instance, $[0.2,0.3,0.4,0.1]^{\top}$ is a unit 4-simplex.
Unit simplexes are most often used as parameters in categorical
or multinomial distributions, and they are also the sampled variate in
a Dirichlet distribution.  Simplexes are declared with their full
dimensionality.  For instance, `theta` is declared to
be a unit $5$-simplex by

单位单纯形是一个非负值向量，其元素之和为1。例如，$[0.2,0.3,0.4,0.1]^{\top}$ 是一个4维单位单纯形。单位单纯形通常用作分类或多项分布中的参数，并且它们也是狄利克雷分布中的采样变量。单纯形需要声明其完整的维数。例如，`theta` 被声明为一个5维单位单纯形：


```stan
simplex[5] theta;
```

Unit simplexes are implemented as vectors and may be assigned to other
vectors and vice-versa.  Simplex variables, like other constrained
variables, are validated to ensure they contain simplex values; for
simplexes, this is only done up to a statically specified accuracy
threshold $\epsilon$ to account for errors arising from floating-point
imprecision.

单位单纯形作为向量实现，可以赋值给其他向量，反之亦然。像其他受约束的变量一样，单纯形变量也会经过验证，以确保它们包含单纯形值；对于单纯形，这种验证只在静态指定的精度阈值 $\epsilon$ 范围内进行，以补偿浮点不精确带来的错误。


In high dimensional problems, simplexes may require smaller step sizes
in the inference algorithms in order to remain stable; this can be
achieved through higher target acceptance rates for samplers and
longer warmup periods, tighter tolerances for optimization with more
iterations, and in either case, with less dispersed parameter
initialization or custom initialization if there are informative
priors for some parameters.

在高维问题中，为了保持稳定，单纯形可能需要在推理算法中使用更小的步长；这可以通过采样器的更高目标接受率和更长的预热期、优化时更严格的容忍度和更多的迭代次数来实现，并且在任何情况下，都可以通过较少分散的参数初始化或自定义初始化来实现，尤其是当某些参数存在信息性先验时。


### Stochastic Matrices {-}

A stochastic matrix is a matrix where each column or row is a
unit simplex, meaning that each column (row) vector has non-negative
values that sum to 1. The following example is a $3 \times 4$
column-stochastic matrix.

$$
\begin{bmatrix}
0.2 & 0.5 & 0.1 & 0.3 \\
0.3 & 0.3 & 0.6 & 0.4 \\
0.5 & 0.2 & 0.3 & 0.3
\end{bmatrix}
$$

An example of a $3 \times 4$ row-stochastic matrix is the following.

$$
\begin{bmatrix}
0.2 & 0.5 & 0.1 & 0.2 \\
0.2 & 0.1 & 0.6 & 0.1 \\
0.5 & 0.2 & 0.2 & 0.1
\end{bmatrix}
$$


In the examples above, each column (or row) sums to 1, making the matrices
valid `column_stochastic_matrix` and `row_stochastic_matrix` types.

Column-stochastic matrices are often used in models where
each column represents a probability distribution across a
set of categories such as in multiple multinomial distributions,
factor models, transition matrices in Markov models,
or compositional data analysis.
They can also be used in situations where you need multiple simplexes
of the same dimensionality.

The `column_stochastic_matrix` and `row_stochastic_matrix` types are declared
with row and column sizes. For instance, a matrix `theta` with
3 rows and 4 columns, where each
column is a 3-simplex, is declared like a matrix with 3 rows and 4 columns.

```stan
column_stochastic_matrix[3, 4] theta;
```

A matrix `theta` with 3 rows and 4 columns, where each row is a 4-simplex,
is similarly declared as a matrix with 3 rows and 4 columns.

```stan
row_stochastic_matrix[3, 4] theta;
```

As with simplexes, `column_stochastic_matrix` and `row_stochastic_matrix`
variables are subject to validation, ensuring that each column (row)
satisfies the simplex constraints. This validation accounts for
floating-point imprecision, with checks performed up to a statically
specified accuracy threshold $\epsilon$.

#### Stability Considerations {-}

In high-dimensional settings, `column_stochastic_matrix` and `row_stochastic_matrix`
types may require careful tuning of the inference
algorithms. To ensure stability:

- **Smaller Step Sizes:** In samplers like Hamiltonian Monte Carlo (HMC),
smaller step sizes can help maintain stability, especially in high dimensions.
- **Higher Target Acceptance Rates:** Setting higher target acceptance
rates can improve the robustness of the sampling process.
- **Longer Warmup Periods:** Increasing the warmup period allows the sampler
to better explore the parameter space before the actual sampling begins.
- **Tighter Optimization Tolerances:** For optimization-based inference,
tighter tolerances with more iterations can yield more accurate results.
- **Custom Initialization:** If prior information about the parameters is
available, custom initialization or less dispersed initialization can lead
to more efficient inference.

### Unit vectors {-}

### 单位向量


A unit vector is a vector with a norm of one.  For instance, $[0.5,
0.5, 0.5, 0.5]^{\top}$ is a unit 4-vector.  Unit vectors are sometimes
used in directional statistics.  Unit vectors are declared with their
full dimensionality.  For instance, `theta` is declared to be a unit
$5$-vector by

单位向量是一个范数为1的向量。例如，$[0.5,0.5, 0.5, 0.5]^{\top}$ 是一个4维单位向量。单位向量有时用于方向统计。单位向量需要声明其完整的维度。例如，theta 被声明为一个5维单位向量：

```stan
unit_vector[5] theta;
```

Unit vectors are implemented as vectors and may be assigned to other
vectors and vice-versa.  Unit vector variables, like other constrained
variables, are validated to ensure that they are indeed unit length; for
unit vectors, this is only done up to a statically specified accuracy
threshold $\epsilon$ to account for errors arising from floating-point
imprecision.

单位向量作为向量实现，可以赋值给其他向量，反之亦然。像其他受约束变量一样，单位向量变量也会经过验证，以确保它们确实是单位长度；对于单位向量，这种验证只在静态指定的精度阈值 $\epsilon$ 范围内进行，以补偿浮点不精确带来的错误。

### Vectors that sum to zero {-}

A zero-sum vector is constrained such that the
sum of its elements is always $0$. These are sometimes useful
for resolving identifiability issues in regression models.
While the underlying vector has only $N - 1$ degrees of freedom,
zero sum vectors are declared with their full dimensionality.
For instance, `beta` is declared to be a zero-sum $5$-vector (4 DoF) by

```stan
sum_to_zero_vector[5] beta;
```

Zero sum vectors are implemented as vectors and may be assigned to other
vectors and vice-versa.  Zero sum vector variables, like other constrained
variables, are validated to ensure that they are indeed unit length; for
zero sum  vectors, this is only done up to a statically specified accuracy
threshold $\epsilon$ to account for errors arising from floating-point
imprecision.

### Ordered vectors {-}

### 有序向量


An ordered vector type in Stan represents a vector whose entries are
sorted in ascending order.  For instance, $(-1.3,2.7,2.71)^{\top}$ is
an ordered 3-vector.  Ordered vectors are most often employed as cut
points in ordered logistic regression models (see
[section](https://mc-stan.org/docs/stan-users-guide/regression.html#ordered-logistic.section)).

Stan中的有序向量类型表示一个其条目按升序排序的向量。例如，$(-1.3,2.7,2.71)^{\top}$ 是一个有序的3维向量。有序向量最常用作有序逻辑回归模型中的切点（见[章节](https://mc-stan.org/docs/stan-users-guide/regression.html#ordered-logistic.section)）。


The variable `c` is declared as an ordered 5-vector by

变量 c 被声明为一个有序的5维向量：

```stan
ordered[5] c;
```

After their declaration, ordered vectors, like unit simplexes, may be
assigned to other vectors and other vectors may be assigned to them.
Constraints will be checked after executing the block in which the
variables were declared.

在声明之后，有序向量和单位单纯形一样，可以被赋值给其他向量，其他向量也可以赋值给它们。在执行声明这些变量的块之后，将检查约束。


### Positive, ordered vectors {-}

### 正有序向量


There is also a positive, ordered vector type which operates similarly
to ordered vectors, but all entries are constrained to be positive.
For instance, $(2,3.7,4,12.9)$ is a positive, ordered 4-vector.

还有一种正的有序向量类型，其运作方式类似于有序向量，但所有元素都被约束为正数。例如，$(2,3.7,4,12.9)$ 是一个正的有序4维向量。

The variable `d` is declared as a positive, ordered 5-vector by

变量 `d` 被声明为一个正的有序5维向量：

```stan
positive_ordered[5] d;
```

Like ordered vectors, after their declaration, positive ordered vectors
may be assigned to other vectors and other vectors may be assigned to them.
Constraints will be checked after executing the block in which the
variables were declared.

像有序向量一样，在它们被声明之后，正的有序向量可以被赋值给其他向量，其他向量也可以赋值给它们。在执行声明这些变量的块之后，将检查约束。




### Row vectors {-}

### 行向量

Row vectors are declared with the keyword `row_vector`.
Like (column) vectors, they are declared with a size.  For example,
a 1093-dimensional row vector `u` would be declared as

行向量使用关键字 `row_vector` 声明。与（列）向量一样，它们在声明时需要指定大小。例如，一个维度为1093的行向量 `u` 将被声明为：


```stan
row_vector[1093] u;
```

Constraints are declared as for vectors, as in the following example
of a 10-vector with values between -1 and 1.

向量的约束同样适用于行向量，如下面这个值介于-1和1之间的10维行向量的例子：

```stan
row_vector<lower=-1, upper=1>[10] u;
```
Offset and multiplier are also similar as for the following 3-row-vector with
offset -42 and multiplier 3.

偏移和乘数的设置也与向量类似，如下面这个具有-42偏移和3倍乘数的3维行向量：

```stan
row_vector<offset=-42, multiplier=3>[3] u;
```

Row vectors may not be assigned to column vectors, nor may column
vectors be assigned to row vectors.  If assignments are required, they
may be accommodated through the transposition operator.

行向量不能赋值给列向量，列向量也不能赋值给行向量。如果需要赋值，可以通过转置操作符来实现。


### Complex row vectors {-}

### 复数行向量


Complex row vectors are declared with the keyword
`complex_row_vector` and given a size in basic declarations.  For
example, a 12-dimensional complex row vector `v` would be declared as

复数行向量使用关键字 complex_row_vector 声明，并在基本声明中指定大小。例如，一个12维的复数行向量 v 将被声明为：


```stan
complex_row_vector[12] v;
```

Complex row vectors do not allow constraints.

复数行向量不允许设置约束。


### Matrices {-}

### 矩阵


Matrices are declared with the keyword `matrix` along with a
number of rows and number of columns.  For example,

矩阵使用关键字 matrix 声明，并指定行数和列数。例如，


```stan
matrix[3, 3] A;
matrix[M, N] B;
```

declares `A` to be a $3 \times 3$ matrix and `B` to be a $M
\times N$ matrix.  For the second declaration to be well formed, the
variables `M` and `N` must be declared as integers in either
the data or transformed data block and before the matrix declaration.

这样声明 `A` 是一个 $3\times3$ 的矩阵，而 `B` 是一个 $M \times N$ 的矩阵。对于第二个声明，变量 `M` 和 `N` 必须在数据或转换数据块中被声明为整数，并且在矩阵声明之前。


Matrices may also be declared with constraints, as in this ($3 \times 4$)
matrix of non-positive values.

矩阵也可以声明带有约束，如这个 ($3\times 4$) 非正值矩阵：

```stan
matrix<upper=0>[3, 4] B;
```

Similarly, matrices can be declared to have a set offset and/or multiplier, as in
this matrix with multiplier 5.

同样，矩阵也可以被声明具有设定的偏移和/或乘数，如这个乘数为5的矩阵：

```stan
matrix<multiplier=5>[3, 4] B;
```

#### Assigning to rows of a matrix {-}

#### 对矩阵的行进行赋值


Rows of a matrix can be assigned by indexing the left-hand side of an
assignment statement. For example, this is possible.

可以通过索引赋值语句的左侧来对矩阵的行进行赋值。例如，这是可行的。


```stan
matrix[M, N] a;
row_vector[N] b;
// ...
a[1] = b;
```

This copies the values from row vector `b` to `a[1]`, which
is the first row of the matrix `a`.  If the number of columns in
`a` is not the same as the size of `b`, a run-time error is
raised;  the number of columns of `a` is `N`, which is also the
number of columns of `b`.

这将行向量 `b` 的值复制到矩阵 `a` 的第一行 `a[1]`。如果 `a` 的列数与 `b` 的大小不同，将引发运行时错误；`a` 的列数是 `N`，这也是 `b` 的列数。

Assignment works by copying values in Stan.  That means any subsequent
assignment to `a[1]` does not affect `b`, nor does an
assignment to `b` affect `a`.

在Stan中，赋值是通过复制值进行的。这意味着对 `a[1]` 的后续赋值不会影响 `b`，对 `b` 的赋值也不会影响 `a`。

### Complex matrices {-}

### 复数矩阵


Complex matrices are declared with the keyword `complex_matrix` and a
number of rows and columns.  For example,

复数矩阵使用关键字 `complex_matrix` 声明，并指定行数和列数。例如，


```stan
complex_matrix[3, 3] C;
```

Complex matrices do not allow constraints.

复数矩阵不允许设置约束。



### Covariance matrices {-}

### 协方差矩阵

Matrix variables may be constrained to represent covariance matrices.
A matrix is a covariance matrix if it is symmetric and positive
definite.  Like correlation matrices, covariance matrices only need a
single dimension in their declaration.  For instance,

矩阵变量可以被约束用来表示协方差矩阵。如果一个矩阵是对称的且正定的，则它是一个协方差矩阵。与相关矩阵一样，协方差矩阵在声明时只需要一个维度。例如，

```stan
cov_matrix[K] Sigma;
```

declares `Sigma` to be a $K \times K$ covariance matrix, where
$K$ is the value of the data variable `K`.

声明 `Omega` 为一个 $K \times K$ 的协方差矩阵，其中 $K$ 是数据变量 `K` 的值。


### Correlation matrices {-}

### 相关矩阵

Matrix variables may be constrained to represent correlation matrices.
A matrix is a correlation matrix if it is symmetric and positive
definite, has entries between $-1$ and $1$, and has a unit diagonal.
Because correlation matrices are square, only one dimension needs
to be declared.  For example,

矩阵变量可以被约束用来表示相关矩阵。如果一个矩阵是对称的且正定的，且元素值介于 $-1$ 到 $1$ 之间，并且对角线上的元素为1，则它是一个相关矩阵。因为相关矩阵是方阵，所以只需要声明一个维度。例如，


```stan
corr_matrix[3] Omega;
```

declares `Omega` to be a $3 \times 3$ correlation matrix.

声明 `Sigma` 为一个 $3 \times 3$ 的相关矩阵。

Correlation matrices may be assigned to other matrices, including
unconstrained matrices, if their dimensions match, and vice-versa.

如果相关矩阵的维度匹配，它们可以被赋值给其他矩阵，包括不受约束的矩阵，反之亦然。


### Cholesky factors of covariance matrices {-}

### 协方差矩阵的 Cholesky 因子


Matrix variables may be constrained to represent the Cholesky factors
of a covariance matrix.  This is often more convenient or more
efficient than representing covariance matrices directly.

矩阵变量可以被约束来表示协方差矩阵的 Cholesky 因子。这通常比直接表示协方差矩阵更方便或更高效。


A Cholesky factor $L$ is an $M \times N$ lower-triangular matrix (if
$m < n$ then $L[m, n] =0$) with a strictly positive diagonal ($L[k, k]
> 0$) and $M \geq N$.  If $L$ is a Cholesky factor, then $\Sigma = L
\, L^{\top}$ is a covariance matrix (i.e., it is positive definite).
The mapping between positive definite matrices and their Cholesky
factors is bijective---every covariance matrix has a unique Cholesky
factorization.

Cholesky 因子 $L$ 是一个 $M \times N$ 的下三角矩阵（如果 $m<n$ 则 $L[m,n]=0$）且对角线严格正（$L[k,k]>0$），并且 $M\geq N$。如果 $L$ 是一个 Cholesky 因子，那么 $\Sigma = L \, L^{\top}$就是一个协方差矩阵（即，它是正定的）。正定矩阵与其 Cholesky 因子之间的映射是双射的---每个协方差矩阵都有唯一的Cholesky分解。


The typical case of a square Cholesky factor may be declared with a
single dimension,

通常情况下，方形 Cholesky 因子可以通过单一维度来声明，

```stan
cholesky_factor_cov[4] L;
```

#### Cholesky factors of positive semi-definite matrices {-}

#### 正半定矩阵的 Cholesky 因子


In general, two dimensions may be declared, with the above being equal to
`cholesky_factor_cov[4, 4]`.  The
type `cholesky_factor_cov[M, N]` may be used for the general
$M \times N$ case to produce positive semi-definite matrices of rank $M$.

通常，可以声明两个维度，上述等同于 `cholesky_factor_cov[4, 4]`。类型 `cholesky_factor_cov[M, N]` 可用于一般的 $M\times N$ 情况，以产生秩为 $M$ 的正半定矩阵。

### Cholesky factors of correlation matrices {-}

### 相关矩阵的 Cholesky 因子


Matrix variables may be constrained to represent the Cholesky factors
of a correlation matrix.

矩阵变量可以被约束来表示相关矩阵的 Cholesky 因子。


A Cholesky factor for a correlation matrix $L$ is a $K \times K$
lower-triangular matrix with positive diagonal entries and rows that
are of length 1 (i.e., $\sum_{n=1}^K L_{m,n}^2 = 1$).  If $L$ is a
Cholesky factor for a correlation matrix, then $L\,L^{\top}$ is a
correlation matrix (i.e., symmetric positive definite with a unit
diagonal).

相关矩阵的 Cholesky 因子 $L$ 是一个 $K\times K$ 的下三角矩阵，其对角线元素为正数，并且每一行的长度为1（即，$\sum_{n=1}^K L_{m,n}^2 = 1$）。如果 $L$ 是相关矩阵的 Cholesky 因子，那么 $L\,L^{\top}$ 就是一个相关矩阵（即，对称正定且对角线为单位元素）。

To declare the variable `L` to be a `K` by `K` Cholesky factor of a
correlation matrix, the following code may be used.

要声明变量 `L`为相关矩阵的 $K \times K$ Cholesky 因子，可以使用以下代码。

```stan
cholesky_factor_corr[K] L;
```


### Assigning constrained variables {-}

### 赋值给受约束的变量

Constrained variables of all types may be assigned to other variables
of the same unconstrained type and vice-versa.  Matching is interpreted strictly
as having the same basic type and number of array dimensions.
Constraints are not considered, but basic data types are. For instance, a
variable declared to be `real<lower=0, upper=1>` could be assigned
to a variable declared as `real` and vice-versa.  Similarly, a
variable declared as `matrix[3, 3]` may be assigned to a variable
declared as `cov_matrix[3]` or
`cholesky_factor_cov[3]`, and vice-versa.

所有类型的受约束变量都可以赋值给相同非约束类型的其他变量，反之亦然。匹配被严格解释为具有相同的基本类型和数组维数。不考虑约束，但考虑基本数据类型。例如，声明为 `real<lower=0, upper=1>`的变量可以赋值给声明为 `real` 的变量，反之亦然。同样，声明为 `matrix[3, 3]` 的变量可以赋值给声明为 `cov_matrix[3]` 或 `cholesky_factor_cov[3]` 的变量，反之亦然。


Checks are carried out at the end of each relevant block of statements
to ensure constraints are enforced.  This includes run-time size
checks.  The Stan compiler isn't able to catch the fact that an
attempt may be made to assign a matrix of one dimensionality to a
matrix of mismatching dimensionality.

在每个相关语句块的末尾进行检查，以确保执行约束。这包括运行时大小检查。Stan编译器无法捕捉到可能试图将一个维度的矩阵赋值给维度不匹配的矩阵的情况。


### Promoting real to complex matrixes {-}

### 实数矩阵升级为复数矩阵


Real-valued vectors, row vectors and matrices may be assigned to
complex-valued vectors, row vectors and matrices, respectively.  For
example, the following is legal.

实数向量、行向量和矩阵可以分别赋值给复数向量、行向量和矩阵。例如，以下操作是允许的。

```stan
vector[N] v = ...;
complex_vector[N] u = 2 * v;
```

Row vectors and matrices work the same way.

行向量和矩阵的处理方式也是相同的。


### Expressions as size declarations {-}

### 表达式用作尺寸声明


Variables may be declared with sizes given by expressions.  Such
expressions are constrained to only contain data or transformed data
variables.  This ensures that all sizes are determined once the data
is read in and transformed data variables defined by their statements.
For example, the following is legal.

变量可以使用表达式声明大小。这些表达式只能包含数据或转换后的数据变量。这确保了一旦数据被读取并且通过它们的声明定义了转换后的数据变量，所有的大小都将被确定。例如，以下操作是合法的。

```stan
data {
  int<lower=0> N_observed, N_missing;
  // ...
transformed parameters {
  vector[N_observed + N_missing] y;
  // ...
```

### Accessing vector and matrix elements {-}

### 访问向量和矩阵元素


If `v` is a column vector or row vector, then `v[2]` is the
second element in the vector.  If `m` is a matrix, then
`m[2, 3]` is the value in the second row and third column.

如果 `v` 是一个列向量或行向量，则 `v[2]` 是向量中的第二个元素。如果 `m` 是一个矩阵，则 `m[2, 3]` 是第二行第三列的值。


Providing a matrix with a single index returns the specified row.  For
instance, if `m` is a matrix, then `m[2]` is the second row.
This allows Stan blocks such as

提供矩阵单个索引将返回指定的行。例如，如果 `m` 是一个矩阵，则 `m[2]` 是第二行。这允许使用 Stan 代码块，如


```stan
matrix[M, N] m;
row_vector[N] v;
real x;
// ...
v = m[2];
x = v[3];   // x == m[2][3] == m[2, 3]
```

The type of `m[2]` is `row_vector` because it is the second
row of `m`.  Thus it is possible to write `m[2][3]` instead
of `m[2, 3]` to access the third element in the second row.  When
given a choice, the form `m[2, 3]` is preferred.

`m[2]` 的类型是行向量，因为它是 `m` 的第二行。因此，可以写 `m[2][3]` 来代替 `m[2, 3]` 来访问第二行的第三个元素。在有选择的情况下，推荐使用 `m[2, 3]` 的形式。


Complex versions work the same way,

复杂版本的工作方式相同，


```stan
complex_matrix[M, N] m = ...;
complex_row_vector[N] u = m[3];
complex_vector[M] v = m[ , 2];
```


#### Array index style {#array-index-style}

#### 数组索引方式


The form `m[2, 3]` is more efficient because it does not require the creation and use of an intermediate expression template for `m[2]`.  In later versions, explicit calls to `m[2][3]` may be optimized to be as efficient as `m[2, 3]` by the Stan compiler.

形式 `m[2, 3]` 更有效率，因为它不需要为 `m[2]` 创建和使用中间表达式模板。在后续版本中，对 `m[2][3]` 的显式调用可能会被 Stan 编译器优化，使其与 `m[2, 3]` 一样高效。


### Size declaration restrictions {-}

### 尺寸声明限制


An integer expression is used to pick out the sizes of vectors,
matrices, and arrays.  For instance, we can declare a vector of size
`M + N` using

使用整数表达式来确定向量、矩阵和数组的大小。例如，我们可以使用下面的方式声明一个大小为 `M + N` 的向量：


```stan
vector[M + N] y;
```

Any integer-denoting expression may be used for the size declaration,
providing all variables involved are either data, transformed data, or
local variables.  That is, expressions used for size declarations may
not include parameters or transformed parameters or generated
quantities.

任何表示整数的表达式都可以用于尺寸声明，前提是涉及的所有变量必须是数据、转换后的数据或局部变量。也就是说，用于尺寸声明的表达式不能包括参数、转换后的参数或生成的量。


## Array data types {#array-data-types.section}

## 数组数据类型


Stan supports arrays of arbitrary dimension.  The values in an array
can be any type, so that arrays may contain values that are simple
reals or integers, vectors, matrices, or other arrays.  Arrays are the
only way to store sequences of integers, and some functions in Stan,
such as discrete distributions, require integer arguments.

Stan 支持任意维度的数组。数组中的值可以是任何类型，因此数组可以包含简单的实数或整数、向量、矩阵或其他数组。数组是存储整数序列的唯一方式，且 Stan 中的一些函数（如离散分布）需要整数参数。


A two-dimensional array is just an array of arrays, both conceptually
and in terms of current implementation.  When an index is supplied to
an array, it returns the value at that index.  When more than one
index is supplied, this indexing operation is chained.  For example, if
`a` is a two-dimensional array, then `a[m, n]` is just
a convenient shorthand for `a[m][n]`.

二维数组实际上就是数组的数组，无论是从概念上还是在当前实现中都是这样。当提供一个索引给数组时，它返回该索引处的值。当提供多个索引时，这种索引操作是连锁的。例如，如果 `a` 是一个二维数组，则 `a[m, n]` 就是 `a[m][n]` 的便捷简写。


Vectors, matrices, and arrays are not assignable to one another, even
if their dimensions are identical.

向量、矩阵和数组之间不能相互赋值，即使它们的尺寸相同。


For constructing arrays in Stan, see [Vector, Matrix, and Array Expressions](expressions.qmd#vector-matrix-array-expressions.section).

有关在 Stan 中构建数组的更多信息，请参见[向量、矩阵和数组表达式](expressions.qmd#vector-matrix-array-expressions.section)。


### Declaring array variables {-}

### 声明数组变量


Arrays are declared with the keyword `array` followed by the dimensions
enclosed in square brackets, the element type, and the name of the variable.

数组使用关键字 `array` 声明，后跟用方括号括起来的维度，元素类型，以及变量名称。


The variable `n` is declared as an array of five integers as follows.

变量 `n` 被声明为一个包含五个整数的数组，如下所示：

```stan
array[5] int n;
```

A two-dimensional array of complex values with three rows and four columns is
declared as follows.

一个具有三行和四列的复数值的二维数组声明如下：


```stan
array[3, 4] complex a;
```

A three-dimensional array `z` of positive reals with five rows, four
columns, and two shelves can be declared as follows.

一个具有五行、四列和两层的正实数的三维数组 `z` 可以如下声明：

```stan
array[5, 4, 2] real<lower=0> z;
```


Arrays may also be declared to contain vectors.  For example,

数组也可以声明为包含向量。例如，


```stan
array[3] vector[7] mu;
```

declares `mu` to be an array of size 3 containing vectors with 7
elements.  Arrays may also contain matrices.  The example

声明 `mu` 为一个大小为 3 的数组，包含有 7 个元素的向量。数组也可以包含矩阵。示例


```stan
array[15, 12] complex_matrix[7, 2] mu;
```

declares a 15 by 12 array of $7 \times 2$ complex matrices.  Any of
the constrained types may also be used in arrays, as in the
declaration

声明一个 $15 \times 12$ 的 $7\times 2$ 的复数矩阵数组。任何约束类型也可用于数组，如


```stan
array[2, 3, 4] cholesky_factor_cov[5, 6] mu;
```

of a $2 \times 3 \times 4$ array of $5 \times 6$ Cholesky factors of
covariance matrices.

声明一个 $2\times 3\times 4$ 的 $5\times 6$ Cholesky 协方差矩阵因子数组。



### Accessing array elements and subarrays {-}

### 访问数组元素和子数组


If `x` is a 1-dimensional array of length 5, then `x[1]` is
the first element in the array and `x[5]` is the last.  For a $3
\times 4$ array `y` of two dimensions, `y[1, 1]` is the first
element and `y[3, 4]` the last element.  For a three-dimensional
array `z`, the first element is `z[1, 1, 1]`, and so on.

如果 `x` 是一个长度为 5 的一维数组，那么 `x[1]` 是数组中的第一个元素，`x[5]` 是最后一个元素。对于一个$3\times 4$的二维数组 `y`，`y[1, 1]` 是第一个元素，`y[3, 4]` 是最后一个元素。对于一个三维数组 `z`，第一个元素是 `z[1, 1, 1]`，依此类推。


Subarrays of arrays may be accessed by providing fewer than the full
number of indexes.  For example, suppose `y` is a two-dimensional
array with three rows and four columns.  Then `y[3]` is
one-dimensional array of length four.  This means that `y[3][1]`
may be used instead of `y[3, 1]` to access the value of the first
column of the third row of `y`.  The form `y[3, 1]` is the
preferred form (see [note](#array-index-style) in this chapter).

通过提供少于完整索引数目，可以访问数组的子数组。例如，假设 `y` 是一个有三行四列的二维数组。那么 `y[3]` 是一个长度为四的一维数组。这意味着可以使用 `y[3][1]` 来代替 `y[3, 1]` 访问 `y` 的第三行第一列的值。推荐使用 `y[3, 1]` 的形式（参见本章[注释](#array-index-style)）。


### Assigning {-}

### 赋值

Subarrays may be manipulated and assigned just like any other
variables.  Similar to the behavior of matrices, Stan allows blocks
such as

子数组可以像其他变量一样被操作和赋值。与矩阵的行为类似，Stan 允许如下代码块：


```stan
array[9, 10, 11] real w;
array[10, 11] real x;
array[11] real y;
real z;
// ...
x = w[5];
y = x[4];  // y == w[5][4] == w[5, 4]
z = y[3];  // z == w[5][4][3] == w[5, 4, 3]
```

Complex-valued arrays work the same way.

复数值数组的工作方式相同。



### Arrays of matrices and vectors {-}

### 矩阵和向量的数组


Arrays of vectors and matrices are accessed in the same way as arrays
of doubles.  Consider the following vector and scalar declarations.

向量和矩阵的数组与双精度浮点数数组的访问方式相同。考虑以下向量和标量声明。


```stan
array[3, 4] vector[5] a;
array[4] vector[5] b;
vector[5] c;
real x;
```

With these declarations, the following assignments are legal.

根据这些声明，以下赋值是合法的。


```stan
b = a[1];       // result is array of vectors
c = a[1, 3];    // result is vector
c = b[3];       //   same result as above
x = a[1, 3, 5]; // result is scalar
x = b[3, 5];    //   same result as above
x = c[5];       //   same result as above
```

``` stan
b = a[1];       // 结果是向量数组
c = a[1, 3];    // 结果是向量
c = b[3];       //   与上面结果相同
x = a[1, 3, 5]; // 结果是标量
x = b[3, 5];    //   与上面结果相同
x = c[5];       //   与上面结果相同
```

Row vectors and other derived vector types (simplex and ordered)
behave the same way in terms of indexing.

行向量和其他派生的向量类型（简单的和有序的）在索引方面的方式相同。

Consider the following matrix, vector and scalar declarations.

考虑以下矩阵、向量和标量声明。


```stan
array[3, 4] matrix[6, 5] d;
array[4] matrix[6, 5] e;
matrix[6, 5] f;
row_vector[5] g;
real x;
```

With these declarations, the following definitions are legal.

根据这些声明，以下定义是合法的。


```stan
e = d[1];           // result is array of matrices
f = d[1, 3];        // result is matrix
f = e[3];           //   same result as above
g = d[1, 3, 2];     // result is row vector
g = e[3, 2];        //   same result as above
g = f[2];           //   same result as above
x = d[1, 3, 5, 2];  // result is scalar
x = e[3, 5, 2];     //   same result as above
x = f[5, 2];        //   same result as above
x = g[2];           //   same result as above
```

``` stan
e = d[1];           // 结果是矩阵数组
f = d[1, 3];        // 结果是矩阵
f = e[3];           //   与上面结果相同
g = d[1, 3, 2];     // 结果是行向量
g = e[3, 2];        //   与上面结果相同
g = f[2];           //   与上面结果相同
x = d[1, 3, 5, 2];  // 结果是标量
x = e[3, 5, 2];     //   与上面结果相同
x = f[5, 2];        //   与上面结果相同
x = g[2];           //   与上面结果相同
```

As shown, the result `f[2]` of supplying a single index to a
matrix is the indexed row, here row 2 of matrix `f`.

如上所示，为矩阵提供单一索引的结果 `f[2]` 是索引的行，这里是矩阵 `f` 的第 2 行。



### Partial array assignment {-}

### 部分数组赋值

Subarrays of arrays may be assigned by indexing on the left-hand side
of an assignment statement.  For example, the following is legal.

数组的子数组可以通过在赋值语句的左侧进行索引来赋值。例如，以下是合法的。



```stan
array[I, J, K] real x;
array[J, K] real y;
array[K] real z;
// ...
x[1] = y;
x[1, 1] = z;
```


The sizes must match.  Here, `x[1]` is a `J` by `K`
array, as is `y`.

尺寸必须匹配。这里，`x[1]` 是一个 J 乘以 K 的数组，`y` 也是。


Partial array assignment also works for arrays of matrices, vectors,
and row vectors.

部分数组赋值同样适用于矩阵、向量和行向量的数组。


### Mixing array, vector, and matrix types {-}

### 混合数组、向量和矩阵类型


Arrays, row vectors, column vectors and matrices are not
interchangeable in Stan.  Thus a variable of any one of these
fundamental types is not assignable to any of the others, nor may it
be used as an argument where the other is required (use as arguments
follows the assignment rules).

在 Stan 中，数组、行向量、列向量和矩阵之间不能互换。因此，这些基本类型中的任何一个变量都不能赋值给其他类型，也不能用作需要其他类型的参数（参数使用遵循赋值规则）。


#### Mixing vectors and arrays {-}

#### 混合向量和数组


For example, vectors cannot be assigned to arrays or vice-versa.

例如，向量不能赋值给数组，反之亦然。


```stan
array[4] real a;
vector[4] b;
row_vector[4] c;
// ...
a = b; // illegal assignment of vector to array
b = a; // illegal assignment of array to vector
a = c; // illegal assignment of row vector to array
c = a; // illegal assignment of array to row vector
```

``` stan
array[4] real a;
vector[4] b;
row_vector[4] c;
// ...
a = b; // 向量赋值给数组是非法的
b = a; // 数组赋值给向量是非法的
a = c; // 行向量赋值给数组是非法的
c = a; // 数组赋值给行向量是非法的
```

#### Mixing row and column vectors {-}

#### 混合行向量和列向量


It is not even legal to assign row vectors to column vectors or vice
versa.

甚至不允许将行向量赋值给列向量，反之亦然。

```stan
vector[4] b;
row_vector[4] c;
// ...
b = c; // illegal assignment of row vector to column vector
c = b; // illegal assignment of column vector to row vector
```


#### Mixing matrices and arrays {-}

#### 混合矩阵和数组

The same holds for matrices, where 2-dimensional arrays may not be
assigned to matrices or vice-versa.

矩阵与数组也是如此，二维数组不能赋值给矩阵，反之亦然。

```stan
array[3, 4] real a;
matrix[3, 4] b;
// ...
a = b;  // illegal assignment of matrix to array
b = a;  // illegal assignment of array to matrix
```

``` stan
array[3, 4] real a;
matrix[3, 4] b;
// ...
a = b;  // 矩阵赋值给数组是非法的
b = a;  // 数组赋值给矩阵是非法的
```


#### Mixing matrices and vectors {-}

#### 混合矩阵和向量


A $1 \times N$ matrix cannot be assigned a row vector or
vice versa.

$1\times N$矩阵不能赋值给行向量，反之亦然。

```stan
matrix[1, 4] a;
row_vector[4] b;
// ...
a = b;  // illegal assignment of row vector to matrix
b = a;  // illegal assignment of matrix to row vector
```

``` stan
matrix[1, 4] a;
row_vector[4] b;
// ...
a = b;  // 行向量赋值给矩阵是非法的
b = a;  // 矩阵赋值给行向量是非法的
```

Similarly, an $M \times 1$ matrix may not be assigned to a column vector.

同样地，$M\times 1$矩阵也不能赋值给列向量。

```stan
matrix[4, 1] a;
vector[4] b;
// ...
a = b;  // illegal assignment of column vector to matrix
b = a;  // illegal assignment of matrix to column vector
```

``` stan
matrix[4, 1] a;
vector[4] b;
// ...
a = b;  // 列向量赋值给矩阵是非法的
b = a;  // 矩阵赋值给列向量是非法的
```

### Size declaration restrictions {-}

### 尺寸声明限制

An integer expression is used to pick out the sizes of arrays.  The
same restrictions as for vector and matrix sizes apply, namely that
the size is declared with an integer-denoting expression that does not
contain any parameters, transformed parameters, or generated quantities.

整数表达式用于指定数组的尺寸。向量和矩阵尺寸的相同限制也适用于此，即尺寸声明必须使用不包含任何参数、转换参数或生成量的表示整数的表达式。


### Size zero arrays {-}

### 零尺寸数组


If any of an array's dimensions is size zero, the entire array will be
of size zero.  That is, if we declare

如果数组的任何一个维度是零尺寸，整个数组将是零尺寸。即，如果我们声明


```stan
array[3, 0] real a;
```

then the resulting size of `a` is zero and querying any of its
dimensions at run time will result in the value zero.  Declared as
above, `a[1]` will be a size-zero one-dimensional array.  For
comparison, declaring

那么 `a` 的结果尺寸为零，并且在运行时查询其任何维度将返回值零。如上声明的 `a[1]` 将是一个零尺寸的一维数组。相比之下，声明


```stan
array[0, 3] real b;
```

also produces an array with an overall size of zero, but in this case,
there is no way to index legally into `b`, because `b[0]` is
undefined.  The array will behave at run time as if it's a $0 \times
0$ array.  For example, the result of `to_matrix(b)` will be a
$0 \times 0$ matrix, not a $0 \times 3$ matrix.

也会产生一个总尺寸为零的数组，但在这种情况下，无法合法地对 `b` 进行索引，因为 `b[0]` 是未定义的。数组将在运行时表现得好像它是一个$0\times 0$ 数组。例如，`to_matrix(b)` 的结果将是一个$0\times 0$矩阵，而不是一个$0\times 3$ 矩阵。



## Tuple data type

## 元组数据类型


Stan supports tuples of arbitrary size.  The values in a tuple can be
of arbitrary type, but the component types must be declared along with
the declaration of the tuple.  Tuples can be manipulated as a whole,
or their elements may be accessed and set individually.

Stan 支持任意大小的元组。元组中的值可以是任意类型，但组成类型必须在声明元组时一并声明。元组可以作为一个整体进行操作，或者可以单独访问和设置其元素。


### Declaring tuple variables {-}

### 声明元组变量

Tuples are declared with the keyword `tuple` followed by a
parenthesized sequence of types, which determine the types of the
respective tuple entries.  For example, a tuple with three elements
may be declared as

元组使用关键字 `tuple` 声明，后跟一组括号内的类型序列，这些类型决定了各个元组条目的类型。例如，一个有三个元素的元组可以声明为


```stan
tuple(int, vector[3], complex) abc;
```

Tuples must have at least two entries, so the following declarations
are illegal.

元组必须至少有两个条目，因此以下声明是非法的。

```stan
tuple() nil;  // ILLEGAL
tuple(int) n;  // ILLEGAL
```

``` stan
tuple() nil;  // 非法
tuple(int) n;  // 非法
```

Tuples can be assigned as a whole if their elements can be assigned
individually.  For example, `a` can be assigned to `b` in the
following example because `int` can be promoted to `complex`.

如果元组的元素可以单独赋值，则可以整体赋值给元组。例如，以下示例中，由于 `int` 可以提升为 `complex`，因此可以将 `a` 赋值给 `b`。


```stan
tuple(int, real) a;
...
tuple(complex, real) b = a;
```

Tuple types may have elements which are declared as tuples, such as
the following example.

元组类型的元素可以声明为元组，如以下示例所示。


```stan
tuple(int, tuple(real, complex)) x;
```

In this case, it would probably be simpler to use a 3-tuple type,
`tuple(int, real, complex)`.

在这种情况下，使用 3-元组类型 `tuple(int, real, complex)` 可能会更简单。


Tuples can be declared with constraints anywhere that ordinary
variables can (i.e., as top-level block variables).  That means any
context in which it is legal to have a declaration

元组可以在普通变量可以声明的任何地方声明带有约束的元组（即，作为顶层块变量）。这意味着在任何合法的地方可以声明


```stan
real<lower=0> sigma;
real<lower=0, upper=1> theta;
```

it is legal to have a tuple with constraints such as

也可以声明带有约束的元组，例如


```stan
tuple(real<lower=0>, real<lower=0, upper=1>) sigma_theta;
```



### Accessing tuple elements {-}

### 访问元组元素


Tuple elements may be accessed directly.  For example, with our
declaration of `abc` from the last section, Stan uses `abc.1` for the
first element, `abc.2` for the second, and `abc.3` for the third.
These numbers must be integer literals (i.e., they cannot be
variables), and must be within the size of the number of elements of
tuples.  The types of elements are as declared, so that `abc.1` is of
type `int`, `abc.2` of type `vector[3]` and `abc.3` of type `complex`.

可以直接访问元组元素。例如，根据上一节的声明 `abc`，Stan 使用 `abc.1` 来访问第一个元素，`abc.2` 访问第二个元素，`abc.3` 访问第三个元素。这些数字必须是整数字面量（即，它们不能是变量），并且必须在元组元素数量的范围内。元素的类型如声明所示，因此 `abc.1` 是 `int` 类型，`abc.2` 是 `vector[3]` 类型，`abc.3` 是 `complex` 类型。


### Assigning tuple elements {-}

### 赋值元组元素


Tuple elements can be assigned individually, allowing, e.g.,

可以单独对元组元素进行赋值，例如，

```stan
tuple(int, real) ab;
ab.1 = 123;
ab.2 = 12.9;
```

As with other assignments, promotions will happen if necessary (of
`int` to `real` and of `real` to `complex`, along with the
corresponding container type promotions).

与其他赋值一样，如果必要，会发生提升（`int` 提升到 `real`，`real` 提升到 `complex`，以及相应的容器类型提升）。


### Unpacking assignment of tuples {-}

### 元组的解包赋值


For convenience of using values stored in tuples, Stan supports
"unpacking" (or "destructuring") of tuples in an assignment statement.

为了方便使用存储在元组中的值，Stan 支持在赋值语句中进行"解包"（或"解构"）。


Given a tuple `t` of type `tuple(T1, ..., Tn)` and a sequence of
[assignable expressions](#rhs-expressions) of types
`v1`, ..., `vn`, where each `vi` has a [type which is assignable](statements.qmd#promotion)
from type `Ti`, individual elements of the tuple may be assigned to the
corresponding variables in the sequence by the statement

给定一个类型为 `tuple(T1, ..., Tn)` 的元组 `t`，以及一系列[可赋值表达式](#rhs-expressions)的类型 `v1, …, vn`，其中每个 `vi` 的[类型可以从 `Ti` 类型赋值](statements.qmd#promotion)，可以通过以下语句将元组的各个元素分别赋值给序列中对应的变量：

```stan
(v1, /*...*/, vn) = t;
```

Note that the above parenthesis are required, unlike in some other
languages with similar features (e.g., Python).

需要注意的是，与其他一些具有类似功能的语言（例如，Python）不同，上述括号是必需的。


These unpacking assignments can be nested if the tuple on the right hand
side contains nested tuples.

这种解包赋值可以嵌套，如果右侧的元组包含嵌套元组。


For example, if `T` is a tuple of type `tuple(int, (real, real), complex)`,
then the program

例如，如果 `T` 是一个类型为 `tuple(int, (real, real), complex)` 的元组，那么程序


```stan
int i;
real x, y;
complex z;

(i, (x, y), z) = T;
```

Assigns the result of `T.1` to `i`, the result of `T.2.1` to `x`,
the result of `T.2.2` to `y`, and the result of `T.3` to `z`.

将 `T.1` 的结果赋给 `i`，`T.2.1` 的结果赋给 `x`，`T.2.2` 的结果赋给 `y`，以及 `T.3` 的结果赋给 `z`。


The left hand side must match in size the tuple on the right.
Additionally, the same variable may not appear more
than once in the left hand side of an unpacking assignment.

左侧的大小必须与右侧的元组匹配。此外，同一个变量在解包赋值的左侧不能出现多于一次。



## Variable types vs. constraints and sizes

## 变量类型 vs. 约束和大小


The type information associated with a variable only contains the
underlying type and dimensionality of the variable.

变量的类型信息仅包含变量的基本（数据）类型和维度。

### Type information excludes sizes {-}

### 类型信息不包括大小


The size associated with a given variable is not part of its data
type.  For example, declaring a variable using

给定变量的大小不是其数据类型的一部分。例如，使用以下方式声明一个变量：

```stan
array[3] real a;
```

declares the variable `a` to be an array.  The fact that it was
declared to have size 3 is part of its declaration, but not part of
its underlying type.

声明变量 `a` 是一个数组。声明其大小为 3是声明的一部分，但不是其基本（数据）类型的一部分。


#### When are sizes checked? {-}

#### 何时检查大小


Sizes are determined dynamically (at run time) and thus cannot be
type-checked statically when the program is compiled.  As a result,
any conformance error on size will raise a run-time error.  For
example, trying to assign an array of size 5 to an array of size 6
will cause a run-time error.  Similarly, multiplying an $N \times M$
by a $J \times K$ matrix will raise a run-time error if $M \neq J$.

大小是在（运行时）动态确定的，所以无法在程序编译时进行静态类型检查。因此，关于大小的任何一致性错误将引发运行时错误。例如，尝试将大小为5 的数组赋给大小为 6 的数组将导致运行时错误。类似地，如果 $M \neq J$，将$N \times M$ 矩阵乘以 $J \times K$ 矩阵将引发运行时错误。


### Type information excludes constraints {-}

### 类型信息不包括约束


Like sizes, constraints are not treated as part of a variable's type
in Stan when it comes to the compile-time check of operations it may
participate in.  Anywhere Stan accepts a matrix as an argument, it
will syntactically accept a correlation matrix or covariance matrix or
Cholesky factor.  Thus a covariance matrix may be assigned to a matrix
and vice-versa.

与大小一样，约束在Stan中不被视为变量类型的一部分，特别是在对其可能参与的操作进行编译检查时。Stan接受矩阵作为参数时，它在语法上也接受相关矩阵、协方差矩阵或Cholesky因子。因此，可以将协方差矩阵赋给矩阵类型变量，反之亦然。


Similarly, a bounded real may be assigned to an unconstrained real and
vice-versa.

类似地，一个有界实数可以赋给不带约束的实数，反之亦然。


#### When are function argument constraints checked? {-}

#### 何时检查函数参数的约束？


For arguments to functions, constraints are sometimes, but not always
checked when the function is called.  Exclusions include C++ standard
library functions.  All probability functions and cumulative
distribution functions check that their arguments are appropriate at
run time as the function is called.

对于函数的参数，有时会在调用函数时检查约束，但并非总是如此。不包括 C++ 标准库函数在内。所有概率函数和累积分布函数在调用函数时都会检查其参数是否恰当。

#### When are declared variable constraints checked? {-}

#### 何时检查声明的变量约束？


For data variables, constraints are checked after the variable is read
from a data file or other source.  For transformed data variables, the
check is done after the statements in the transformed data block have
executed.  Thus it is legal for intermediate values of variables to
not satisfy declared constraints.

对于数据变量，从数据文件或其他来源中读取变量后对约束进行检查。对于变换后的数据变量，在变换数据代码块中的语句执行后进行检查。因此，中间变量值不满足声明的约束是合法的。

For parameters, constraints are enforced by the transform applied and
do not need to be checked.  For transformed parameters, the check is
done after the statements in the transformed parameter block have
executed.

对于参数，约束通过变换强制执行，无需检查。对于变换后的参数，在变换参数代码块中的语句执行后进行检查。

For all blocks defining variables (transformed data, transformed
parameters, generated quantities), real values are initialized to
`NaN` and integer values are initialized to the smallest legal
integer (i.e., a large absolute value negative number).

对于所有定义变量（转换数据、转换参数、生成量）的代码块，实数值被初始化为 `NaN`，整数值被初始化为最小的合法整数（即一个绝对值很大的负数）。


For generated quantities, constraints are enforced after the
statements in the generated quantities block have executed.

对于生成量，约束在生成量代码块中的语句执行后进行强制执行。

### Type naming notation {-}

### 类型命名约定


In order to refer to data types, it is convenient to have a way to
refer to them.  The type naming notation outlined in this section is
not part of the Stan programming language, but rather a convention
adopted in this document to enable a concise description of a type.

为了引用数据类型，我们需要一种便捷的方式来指代它们。本节中概述的类型命名约定不是 Stan 编程语言的一部分，而是本文档采用的一种约定，以便简明地描述类型。


Because size information is not part of a data type, data types will
be written without size information.  For instance, `array[] real` is the
type of one-dimensional array of reals and `matrix` is the type of
matrices.  The three-dimensional integer array type is written as
`array[,,] int`, indicating the number slots available for indexing.
Similarly, `array[,] vector` is the type of a two-dimensional array of
vectors.

因为大小信息不是数据类型的一部分，所以在写数据类型时不用写大小信息。例如，`array[] real`是一维实数数组类型，而 `matrix` 是矩阵的类型。三维整数数组类型写作`array[,,] int`，表示可用于索引的槽位数量。类似地，`array[,] vector`是向量的二维数组类型。



## Variable declaration {#variable-declaration.section}

## 变量声明


Variables in Stan are declared by giving a type and a name. For example

在 Stan 中，变量的声明是通过给出类型和名称来完成的。例如，


```stan
int N;
vector[N] y;
array[5] matrix[3, 4] A;
```

declares a variable `N` that is an integer, a variable `y` that is
a vector of length `N` (the previously declared variable), and a
variable `A`, which is a length-5 array where each element is a 3 by 4
matrix.

声明了一个变量 `N`，它是一个整数，一个变量`y`，它是长度为`N`（之前声明的变量）的向量，以及一个变量 `A`，它是长度为5 的数组，数组中每个元素都是一个 3 行 4 列的矩阵。

The size of top-level variables in the `parameters`, `transformed parameters`, and `generated quantities`
must remain constant across all iterations, therefore only data variables can be used in top-level size declarations.

```stan
// illegal and will be flagged by the compiler:
generated quantities {
  int N = 10;
  array[N] int foo;
```

Depending on where the variable is declared in the Stan program,
it either must or cannot have size information, and constraints
are either optional or not allowed.

在 Stan 中，变量可以在几个不同的地方声明。它们是代码块变量，比如在`data`内部的变量，可以有[约束](#constrained-data-types)并且它们的类型必须包含大小，就像上面的例子一样。局部变量，比如在循环或局部代码块内定义的变量不能被约束，但仍然包括大小。最后，声明为[函数参数](user-functions.qmd#argument-types-and-qualifiers)的变量不是带约束类型，并且*不包括*大小。


```stan
// valid block variables, but not locals or function parameters
vector<lower=0>[N] u;

// valid as a block or local variable, but not a function parameter
array[3] int is;

// function parameters exclude sizes and cannot be constrained
void pretty_print_tri_lower(matrix x) { ... }
```

Top-level variables can have [constraints](#constrained-data-types) and
must include sizes for their types, as in the above examples.
Local variables, like those defined inside loops or local blocks cannot be constrained, but still include sizes.
Finally, variables declared as [function parameters](user-functions.qmd#argument-types-and-qualifiers)
are not constrained types and _exclude_ sizes.

In the following table, the leftmost column is a list of the
unconstrained and undimensioned basic types; these are used as
function return types and argument types.  The middle column is of
unconstrained types with dimensions; these are used as local variable
types. The variables `M` and `N` indicate number of columns and rows,
respectively.  The variable `K` is used for square matrices, i.e., `K`
denotes both the number of rows and columns.
The rightmost column lists the corresponding constrained types.
An expression of any right-hand
column type may be assigned to its corresponding left-hand column basic
type.  At runtime, dimensions are checked for consistency for all
variables; containers of any sizes may be assigned to function
arguments.  The constrained matrix types `cov_matrix[K]`,
`corr_matrix[K]`, `cholesky_factor_cov[K]`, and
`cholesky_factor_corr[K]` are only assignable to matrices of
dimensions `matrix[K, K]` types.

在下表中，最左侧列是不带约束和没有指定维度的基本类型列表；这些用作函数返回类型和参数类型。中间列是指定维度的不带约束类型；这些用作局部变量类型。变量`M` 和 `N` 分别表示列数和行数，变量 `K` 表示方阵的行数和列数。最右侧列列出了相应的约束类型。任何右侧列类型的表达式都可以赋值给其对应的左侧列基本类型。在运行时，所有变量的维度都会进行一致性检查；任何大小的容器都可以赋值给函数参数。带约束的矩阵类型`cov_matrix[K]`、`corr_matrix[K]`、`cholesky_factor_cov[K]` 和`cholesky_factor_corr[K]` 只能赋值给维度为 `matrix[K, K]` 类型的矩阵。

+---------------------+-------------------------+----------------------------------------------+
| Function Argument   |        Local            |                   Block                      |
|     (unsized)       |    (unconstrained)      |               (constrained)                  |
+:====================+:========================+:=============================================+
| `int`               | `int`                   | `int`                                        |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `int<lower=L>`                               |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `int<upper=U>`                               |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `int<lower=L, upper=U>`                      |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `int<offset=O>`                              |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `int<multiplier=M>`                          |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `int<offset=O, multiplier=M>`                |
+---------------------+-------------------------+----------------------------------------------+
| `real`              | `real`                  | `real`                                       |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `real<lower=L>`                              |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `real<upper=U>`                              |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `real<lower=L, upper=U>`                     |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `real<offset=O>`                             |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `real<multiplier=M>`                         |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `real<offset=O, multiplier=M>`               |
+---------------------+-------------------------+----------------------------------------------+
| `complex`           | `complex`               | `complex`                                    |
+---------------------+-------------------------+----------------------------------------------+
| `vector`            | `vector[N]`             | `vector[N]`                                  |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `vector[N]<lower=L>`                         |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `vector[N]<upper=U>`                         |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `vector[N]<lower=L, upper=U>`                |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `vector[N]<offset=O>`                        |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `vector[N]<multiplier=M>`                    |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `vector[N]<offset=O, multiplier=M>`          |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `ordered[N]`                                 |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `positive_ordered[N]`                        |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `simplex[N]`                                 |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `unit_vector[N]`                             |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `sum_to_zero_vector[N]`                      |
+---------------------+-------------------------+----------------------------------------------+
| `row_vector`        | `row_vector[N]`         | `row_vector[N]`                              |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `row_vector[N]<lower=L>`                     |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `row_vector[N]<upper=U>`                     |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `row_vector[N]<lower=L, upper=U>`            |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `row_vector[N]<offset=O>`                    |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `row_vector[N]<multiplier=M>`                |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `row_vector[N]<offset=O, multiplier=M>`      |
+---------------------+-------------------------+----------------------------------------------+
| `matrix`            | `matrix[M, N]`          | `matrix[M, N]`                               |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `matrix[M, N]<lower=L>`                      |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `matrix[M, N]<upper=U>`                      |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `matrix[M, N]<lower=L, upper=U>`            |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `matrix[M, N]<offset=O>`                     |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `matrix[M, N]<multiplier=M>`                 |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `matrix[M, N]<offset=O, multiplier=M>`       |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `column_stochastic_matrix[M, N]`             |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `row_stochastic_matrix[M, N]`                |
+---------------------+-------------------------+----------------------------------------------+
|                     | `matrix[K, K]`          | `corr_matrix[K]`                             |
+---------------------+-------------------------+----------------------------------------------+
|                     | `matrix[K, K]`          | `cov_matrix[K]`                              |
+---------------------+-------------------------+----------------------------------------------+
|                     | `matrix[K, K]`          | `cholesky_factor_corr[K]`                    |
+---------------------+-------------------------+----------------------------------------------+
|                     | `matrix[K, K]`          | `cholesky_factor_cov[K]`                     |
+---------------------+-------------------------+----------------------------------------------+
| `complex_vector`    | `complex_vector[M]`     | `complex_vector[M]`                          |
+---------------------+-------------------------+----------------------------------------------+
| `complex_row_vector`| `complex_row_vector[N]` | `complex_row_vector[N]`                      |
+---------------------+-------------------------+----------------------------------------------+
| `complex_matrix`    | `complex_matrix[M, N]`  | `complex_matrix[M,N]`                        |
+---------------------+-------------------------+----------------------------------------------+
| `array[] vector`    | `array[M] vector[N]`    | `array[M] vector[N]`                         |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `array[M] vector[N]<lower=L>`                |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `array[M] vector[N]<upper=U>`                |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `array[M] vector[N]<lower=L, upper=U>`       |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `array[M] vector[N]<offset=O>`               |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `array[M] vector[N]<multiplier=M>`           |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `array[M] vector[N]<offset=O, multiplier=M>` |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `array[M] ordered[N]`                        |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `array[M] positive_ordered[N]`               |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `array[M] simplex[N]`                        |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `array[M] unit_vector[N]`                    |
+---------------------+-------------------------+----------------------------------------------+
|                     |                         | `array[M] sum_to_zero_vector[N]`             |
+---------------------+-------------------------+----------------------------------------------+

<a name="id:constrained-types.figure"></a>

Additional array types follow the same basic template as the final
example in the table and can contain any of the previous types.
The unsized version of arrays with more than one dimension is
specified by using commas, e.g. `array[ , ]` is a 2-D array.

其他的数组类型遵循表中最后一个示例相同的基本模板，并且可以包含任何先前的类型。具有多个维度的大小不确定的数组通过使用逗号来指定维度，例如，`array[ , ]` 是一个二维数组。

For more on how function arguments and return types are declared,
consult the [User's Guide chapter on
functions](https://mc-stan.org/docs/stan-users-guide/user-functions.html#basic-functions.section#type-declarations-for-functions).

更多有关如何声明函数参数和返回类型的信息，请参阅[函数章节的用户指南](https://mc-stan.org/docs/stan-users-guide/user-functions.html#basic-functions.section#type-declarations-for-functions)。


## Compound variable declaration and definition

## 复合变量声明和定义

Stan allows assignable variables to be declared and defined in a
single statement.  Assignable variables are

Stan允许将可赋值变量在单个语句中声明和定义。可赋值变量包括：

* local variables, and
* variables declared in the transformed data,
transformed parameters, or generated quantities blocks.

* 局部变量，以及
* 在转换数据、转换参数或生成量代码块中声明的变量。


For example, the statement

例如，语句

```stan
int N = 5;
```

declares the variable `N` to be an integer scalar type and at the
same time defines it to be the value of the expression `5`.

声明变量 `N` 为整数标量类型，并同时定义它的值为 `5`。


### Assignment typing {-}

### 赋值类型

The type of the expression on the right-hand side of the assignment
must be assignable to the type of the variable being declared.  For
example, it is legal to have

赋值语句右侧表达式的类型必须可以赋值给声明变量的类型。例如，是合法的，


```stan
real sum = 0;
```

even though `0` is of type `int` and `sum` is of type `real`, because
integer-typed scalar expressions can be assigned to real-valued scalar
variables.  In all other cases, the type of the expression on the
right-hand side of the assignment must be identical to the type of the
variable being declared.

尽管 `0` 是 `int` 类型，而 `sum` 是`real`类型，因为可以将整数型的标量表达式赋值给实数型标量变量。在所有其他情况下，赋值语句右侧表达式的类型必须与声明变量的类型相同。


Variables of any type may have values assigned to them.  For example,

任何类型的变量都可以被赋值。例如，


```stan
matrix[3, 2] a = b;
```

declares a $3 \times 2$ matrix variable `a` and assigns a copy
of the value of `b` to the variable `a`.  The variable `b` must
be of type `matrix` for the statement to be well formed.  For
the code to execute successfully, `b` must be the same shape as `a`,
but this cannot be validated until run time.  Because a copy is
assigned, subsequent changes to `a` do not affect `b` and subsequent
changes to `b` do not affect `a`.

声明了一个 $3 \times 2$ 的矩阵变量 `a`，并将 `b` 的值的副本赋给变量 `a`。变量 `b` 必须是 `matrix` 类型才能使语句合法。要成功执行代码，`b` 必须与`a`具有相同的形状，但这直到运行时才能验证。由于赋值了一个副本，对 `a` 的后续更改不会影响 `b`，对 `b` 的后续更改也不会影响 `a`。


### Right-hand side expressions {#rhs-expressions}

### 右侧表达式


The right-hand side may be any expression which has a type which is
assignable to the variable being declared.  For example,

右侧表达式可以是任何表达式，只要其类型可以赋值给正在声明的变量。例如，


```stan
matrix[3, 2] a = 0.5 * (b + c);
```

assigns the matrix variable `a` to half of the sum of `b` and `c`.
The only requirement on `b` and `c` is that the expression `b + c` be
of type `matrix`.  For example, `b` could be of type `matrix` and `c`
of type `real`, because adding a matrix to a scalar produces a matrix,
and the multiplying by a scalar produces another matrix.

将矩阵变量 `a` 赋值为 `b` 和 `c` 的和的一半。对 `b` 和 `c` 的唯一要求是表达式 `b + c` 的类型必须是 `matrix`。例如，`b` 可以是 `matrix` 类型，`c` 可以是 `real` 类型，因为将矩阵与标量相加是一个矩阵，并且乘以标量会产生另一个矩阵。


Similarly,

同样地，


```stan
complex z = 2 + 3i;
```

assigns the  the complex number $2 + 3i$ to the complex scalar `z`.
The right-hand side expression can be a call to a user defined
function, allowing general algorithms to be applied that might not be
otherwise expressible as simple expressions (e.g., iterative or
recursive algorithms).

将复数 $2+3i$ 赋给复数标量`z`。右侧表达式可以是调用用户定义的函数，从而允许应用可能无法以简单表达式（例如，迭代或递归算法）表示的一般算法。



### Scope within expressions {-}

### 表达式内的作用域

Any variable that is in scope and any function that is available in
the block in which the compound declaration and definition appears may
be used in the expression on the right-hand side of the compound
declaration and definition statement.

在复合声明和定义语句的右侧表达式中，可以使用任何在作用域内的变量和任何在代码块中的函数。



## Declaring multiple variables at once

## 同时声明多个变量


Stan will interpret multiple comma-separated variable names following a single
type as declaring multiple new variables.
This is available for all variable declarations in all blocks.

Stan 将跟随在单个类型后的多个逗号分隔的变量名解释为声明多个新变量。这对所有代码块中的所有变量声明都是有效的。


### Types for multiple declarations {-}

### 多重声明的类型


The code:

以下代码：

```stan
real x, y;
```
is equivalent to

等价于：


```stan
real x;
real y;
```

As a result, all declarations on the same line must be of the same type.

因此，同一行上的所有声明必须是相同类型的。


### Combining with other features {-}

### 与其他功能结合使用


The ability to declare multiple variables can be combined with assignments
whenever a declare-define is valid, as documented in
[the section introducing compound declarations and definitions](#compound-variable-declaration-and-definition)
:

在声明和定义合法的情况下多个变量声明与赋值可以一起进行，如[复合声明和定义章节](#compound-variable-declaration-and-definition)所述：


```stan
real x = 3, y = 5.6;
```

[Constrained data types](#constrained-data-types) can also be declared
together, so long as the constraint for each variable is the same:

[带约束的数据的类型](#constrained-data-types)也可以一起声明，只要每个变量的约束相同：

```stan
real<lower=0> x, y;
```
